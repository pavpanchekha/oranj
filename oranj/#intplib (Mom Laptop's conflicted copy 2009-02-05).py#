#!/usr/bin/env python

from __future__ import division

def orpy(name):
    def dec(f):
        def t(self, *args, **kwargs):
            if "$$python" in self.dict:
                f(self, *args, **kwargs)
            else:
                return getattr(self("$$python"), name)(*args, **kwargs)
        return t
    return dec

class OrObject(object):
    py2np = {
        "__init__": "$$new",
        "__del__": "$$del",
        # Implement __str__ somehow
        "__lt__": "$$lt",
        "__le__": "$$le",
        "__gt__": "$$gt",
        "__ge__": "$$ge",
        "__eq__": "$$eq",
        "__ne__": "$$ne",
        "__call__": "$$call",
        "__contains__": "$$in",
        "__add__": "$$add",
        "__sub__": "$$sub",
        "__mul__": "$$mus",
        "__pow__": "$$exp",
        "__truediv__": "$$div",
        "__floordiv__": "$$floor",
        "__mod__": "$$mod",
        "read": "$$output",
        "write": "$$input",
    }

    def __init__(self, name="", classobj=None):
        self.dict = {}

        if name:
            self.set("$$name", name)
        if classobj:
            self.set("$$class", classobj)

    def get(self, key):
        return self.dict[key]

    def set(self, key, value):
        self.dict[key] = value

    @orpy*
    def __repr__(self):
        if "$$python" in self.dict:
            return repr(self.get("$$python"))
        else:
            return "<" + str(self.get("$$class")) + " " + self.get("$$name") + ">"

    def __nonzero__(self):
        if "$$python" in self.dict:
            return bool(self.get("$$python"))
        else:
            # TODO: implement bool
            return True

    @classmethod
    def from_py(cls, obj):
        if hasattr(obj, "__name__"):
            n = obj.__name__
        else:
            n = ""

        if hasattr(obj, "__class__"):
            c = obj.__class__
        else:
            c = None

        np = cls(n, c)

        for i in dir(obj):
            if i in ("__name__", "__class__"):
                continue
            elif i in cls.py2np:
                np.set(cls.py2np[i], getattr(obj, i))
            elif i.startswith("__") and i.endswith("__"):
                np.set("$$" + i[2:-2], getattr(obj, i))
            else:
                #TODO: make this recursive
                np.set(i, getattr(obj, i))
        np.set("$$python", obj)
        return np

class InheritDict:
    def __init__(self, parent=None):
        self.parent = parent
        self.dict = {}

    def update(self, keys={}):
        self.dict.update(keys)

    def __getitem__(self, key):
        if key in self.dict:
            return self.dict[key]
        else:
            try:
                a = self.parent[key]
                self[key] = a # Cache lookup
                return a
            except TypeError:
                raise AttributeError("Key not in InheritDict")

    def __setitem__(self, key, value):
        self.dict[key] = value

    def __delitem__(self, key):
        del self.dict[key]

    def __contains__(self, key):
        return key in self.dict or self.parent and key in self.parent

    def keys(self):
        return list(self.dict.keys()) + self.parent.keys()

def simpleop(f, name):
    def t(*args):
        if all("$$python" in i.dict for i in args):
            args = [i.get("$$python") for i in args]
            return OrObject.from_py(f(*args))
        else:
            try:
                return a.get("$$" + name)(b)
            except:
                return b.get("$$r_" + name)(a)
    return t

add = simpleop(lambda x, y: x + y, "add")
sub = simpleop(lambda x, y: x - y, "sub")
mul = simpleop(lambda x, y: x * y, "mul")
div = simpleop(lambda x, y: x / y, "div")
exp = simpleop(lambda x, y: x ** y, "exp")
floor = simpleop(lambda x, y: x // y, "floor")
mod = simpleop(lambda x, y: x % y, "mod")
or_ = simpleop(lambda x, y: x or y, "or")
and_ = simpleop(lambda x, y: x and y, "and")
not_ = simpleop(lambda x: not x, "not")
in_ = simpleop(lambda x, y: x in y, "in")
not_in = simpleop(lambda x, y: x not in y, "not_in")
is_ = simpleop(lambda x, y: isinstance(x, y), "is")
is_not = simpleop(lambda x, y: not isinstance(x, y), "is_not")
lt = simpleop(lambda x, y: x < y, "lt")
gt = simpleop(lambda x, y: x > y, "gt")
le = simpleop(lambda x, y: x <= y, "le")
ge = simpleop(lambda x, y: x >= y, "ge")
ne = simpleop(lambda x, y: x != y, "ne")
eq = simpleop(lambda x, y: x == y, "eq")
input = simpleop(lambda x, y: x.read(y), "input")
output = simpleop(lambda x, y: x.write(y), "output")
uplus = simpleop(lambda x: +x, "uplus")
uminus = simpleop(lambda x: -x, "uminus")

def call(obj, *args, **kwargs):
    if all("$$python" in i.dict for i in args) and all("$$python" in i.dict for k, i in kwargs.items()):
        args = [i.get("$$python") for i in args]
        for i in kwargs:
            kwargs[i] = kwargs[i].get("$$python")
        obj = obj.get("$$python")
        
        obj(*args, **kwargs)
    else:
        obj.get("$$call")(*args, **kwargs)

getattr_ = simpleop(lambda x, y: getattr(x, y), "getattr")
getindex_ = simpleop(lambda x, y: x[y], "getindex")
