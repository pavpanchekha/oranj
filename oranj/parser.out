shift/reduce conflict in state 100 resolved as shift.
reduce/reduce conflict in state 162 resolved using rule 19 (list_items -> expression .).
reduce/reduce conflict in state 163 resolved using rule 86 (test_basis -> ident .).
shift/reduce conflict in state 219 resolved as shift.


Unused terminals:

   FN
   WITH
   CLASS
   FINALLY

Grammar

Rule 1     primitive -> DEC
Rule 2     primitive -> STRING
Rule 3     primitive -> INT
Rule 4     primitive -> NIL
Rule 5     primitive -> BOOL
Rule 6     primitive -> INF
Rule 7     ident -> IDENT
Rule 8     literal -> [ list_items ]
Rule 9     literal -> [ list_items , ]
Rule 10    literal -> [ ]
Rule 11    literal -> [ hash_items ]
Rule 12    literal -> [ hash_items , ]
Rule 13    literal -> { list_items }
Rule 14    literal -> { list_items , }
Rule 15    literal -> { hash_items }
Rule 16    literal -> { hash_items , }
Rule 17    literal -> { }
Rule 18    list_items -> list_items , expression
Rule 19    list_items -> expression
Rule 20    hash_items -> hash_items , primitive : expression
Rule 21    hash_items -> hash_items , ident : expression
Rule 22    hash_items -> primitive : expression
Rule 23    hash_items -> ident : expression
Rule 24    test_or -> test_or OR test_and
Rule 25    test_or -> test_and
Rule 26    test_and -> test_and AND test_not
Rule 27    test_and -> test_not
Rule 28    test_not -> NOT test_in
Rule 29    test_not -> test_in
Rule 30    test_in -> test_in IN test_type
Rule 31    test_in -> test_in NOT IN test_type
Rule 32    test_in -> test_in | test_type
Rule 33    test_in -> test_type
Rule 34    test_type -> test_type IS test_comp
Rule 35    test_type -> test_type IS NOT test_comp
Rule 36    test_type -> test_comp
Rule 37    test_comp -> test_comp < test_io
Rule 38    test_comp -> test_comp LE test_io
Rule 39    test_comp -> test_comp > test_io
Rule 40    test_comp -> test_comp GE test_io
Rule 41    test_comp -> test_comp NE test_io
Rule 42    test_comp -> test_comp EQ test_io
Rule 43    test_comp -> test_io
Rule 44    test_io -> test_io LTLT test_pm
Rule 45    test_io -> test_io GTGT test_pm
Rule 46    test_io -> test_pm
Rule 47    test_pm -> test_pm + test_mdmf
Rule 48    test_pm -> test_pm - test_mdmf
Rule 49    test_pm -> test_mdmf
Rule 50    test_mdmf -> test_mdmf * test_un
Rule 51    test_mdmf -> test_mdmf / test_un
Rule 52    test_mdmf -> test_mdmf SLASHSLASH test_un
Rule 53    test_mdmf -> test_mdmf MOD test_un
Rule 54    test_mdmf -> test_un
Rule 55    test_un -> test_un PLUSPLUS
Rule 56    test_un -> test_un MINUSMINUS
Rule 57    test_un -> - test_un
Rule 58    test_un -> + test_un
Rule 59    test_un -> test_exp
Rule 60    test_exp -> test_call ^ test_exp
Rule 61    test_exp -> test_call
Rule 62    test_call -> test_call ( arglist )
Rule 63    test_call -> test_call ( arglist , )
Rule 64    test_call -> test_attr
Rule 65    arglist -> arglist , arg
Rule 66    arglist -> arg
Rule 67    arglist -> <empty>
Rule 68    arg -> expression
Rule 69    arg -> ident = expression
Rule 70    arg -> * ident
Rule 71    arg -> * * ident
Rule 72    test_attr -> test_attr . test_sub
Rule 73    test_attr -> test_sub
Rule 74    test_sub -> test_sub [ index ]
Rule 75    test_sub -> test_sub [ index , ]
Rule 76    test_sub -> test_basis
Rule 77    index -> index , indice
Rule 78    index -> indice
Rule 79    indice -> expression : expression : expression
Rule 80    indice -> expression : expression
Rule 81    indice -> expression
Rule 82    indice -> DOTDOTDOT
Rule 83    indice -> <empty>
Rule 84    test_basis -> primitive
Rule 85    test_basis -> literal
Rule 86    test_basis -> ident
Rule 87    test_basis -> ( expression )
Rule 88    expression -> test_or
Rule 89    statement -> expression
Rule 90    statement -> var_s
Rule 91    statement -> flow_s
Rule 92    statement -> assert_s
Rule 93    statement -> block_s
Rule 94    statement -> import_s
Rule 95    statement -> assignment
Rule 96    statement -> declaration
Rule 97    assignment -> many_idents EQOP comma_list
Rule 98    declaration -> ident assignment
Rule 99    var_s -> DEL many_idents
Rule 100   var_s -> EXTERN many_idents
Rule 101   many_idents -> many_idents , ident
Rule 102   many_idents -> ident
Rule 103   flow_s -> BREAK flow_item
Rule 104   flow_s -> CONTINUE flow_item
Rule 105   flow_s -> RETURN comma_list
Rule 106   flow_s -> RETURN comma_list ,
Rule 107   flow_s -> THROW flow_item
Rule 108   flow_s -> YIELD comma_list
Rule 109   flow_s -> YIELD comma_list ,
Rule 110   flow_item -> expression
Rule 111   flow_item -> <empty>
Rule 112   comma_list -> comma_list , expression
Rule 113   comma_list -> expression
Rule 114   import_s -> IMPORT import_items
Rule 115   import_s -> IMPORT import_items AS ident
Rule 116   import_items -> ident . import_items
Rule 117   import_items -> ident
Rule 118   import_items -> *
Rule 119   assert_s -> ASSERT expression
Rule 120   assert_s -> ASSERT expression , expression
Rule 121   block_s -> if_s
Rule 122   block_s -> while_s
Rule 123   block_s -> for_s
Rule 124   block_s -> try_s
Rule 125   if_s -> if_if if_elifs else
Rule 126   if_if -> IF expression block
Rule 127   if_elifs -> ELIF expression block if_elifs
Rule 128   if_elifs -> <empty>
Rule 129   else -> ELSE block
Rule 130   else -> <empty>
Rule 131   block -> { statements }
Rule 132   while_s -> WHILE expression block else
Rule 133   while_s -> WHILE block else
Rule 134   for_s -> FOR many_idents IN comma_list block else
Rule 135   try_s -> try_try try_catch else
Rule 136   try_try -> TRY block
Rule 137   try_catch -> CATCH expression block try_catch
Rule 138   try_catch -> CATCH expression AS ident block try_catch
Rule 139   try_catch -> <empty>
Rule 140   statements -> statements NEWLINE
Rule 141   statements -> statements NEWLINE statement
Rule 142   statements -> statement
Rule 143   statements -> <empty>

Terminals, with rules where they appear

(                    : 62 63 87
)                    : 62 63 87
*                    : 50 70 71 71 118
+                    : 47 58
,                    : 9 12 14 16 18 20 21 63 65 75 77 101 106 109 112 120
-                    : 48 57
.                    : 72 116
/                    : 51
:                    : 20 21 22 23 79 79 80
<                    : 37
=                    : 69
>                    : 39
AND                  : 26
AS                   : 115 138
ASSERT               : 119 120
BOOL                 : 5
BREAK                : 103
CATCH                : 137 138
CLASS                : 
CONTINUE             : 104
DEC                  : 1
DEL                  : 99
DOTDOTDOT            : 82
ELIF                 : 127
ELSE                 : 129
EQ                   : 42
EQOP                 : 97
EXTERN               : 100
FINALLY              : 
FN                   : 
FOR                  : 134
GE                   : 40
GTGT                 : 45
IDENT                : 7
IF                   : 126
IMPORT               : 114 115
IN                   : 30 31 134
INF                  : 6
INT                  : 3
IS                   : 34 35
LE                   : 38
LTLT                 : 44
MINUSMINUS           : 56
MOD                  : 53
NE                   : 41
NEWLINE              : 140 141
NIL                  : 4
NOT                  : 28 31 35
OR                   : 24
PLUSPLUS             : 55
RETURN               : 105 106
SLASHSLASH           : 52
STRING               : 2
THROW                : 107
TRY                  : 136
WHILE                : 132 133
WITH                 : 
YIELD                : 108 109
[                    : 8 9 10 11 12 74 75
]                    : 8 9 10 11 12 74 75
^                    : 60
error                : 
{                    : 13 14 15 16 17 131
|                    : 32
}                    : 13 14 15 16 17 131

Nonterminals, with rules where they appear

arg                  : 65 66
arglist              : 62 63 65
assert_s             : 92
assignment           : 95 98
block                : 126 127 129 132 133 134 136 137 138
block_s              : 93
comma_list           : 97 105 106 108 109 112 134
declaration          : 96
else                 : 125 132 133 134 135
expression           : 18 19 20 21 22 23 68 69 79 79 79 80 80 81 87 89 110 112 113 119 120 120 126 127 132 137 138
flow_item            : 103 104 107
flow_s               : 91
for_s                : 123
hash_items           : 11 12 15 16 20 21
ident                : 21 23 69 70 71 86 98 101 102 115 116 117 138
if_elifs             : 125 127
if_if                : 125
if_s                 : 121
import_items         : 114 115 116
import_s             : 94
index                : 74 75 77
indice               : 77 78
list_items           : 8 9 13 14 18
literal              : 85
many_idents          : 97 99 100 101 134
primitive            : 20 22 84
statement            : 141 142
statements           : 131 140 141 0
test_and             : 24 25 26
test_attr            : 64 72
test_basis           : 76
test_call            : 60 61 62 63
test_comp            : 34 35 36 37 38 39 40 41 42
test_exp             : 59 60
test_in              : 28 29 30 31 32
test_io              : 37 38 39 40 41 42 43 44 45
test_mdmf            : 47 48 49 50 51 52 53
test_not             : 26 27
test_or              : 24 88
test_pm              : 44 45 46 47 48
test_sub             : 72 73 74 75
test_type            : 30 31 32 33 34 35
test_un              : 50 51 52 53 54 55 56 57 58
try_catch            : 135 137 138
try_s                : 124
try_try              : 135
var_s                : 90
while_s              : 122


Parsing method: LALR


state 0

    (0) S' -> . statements
    (140) statements -> . statements NEWLINE
    (141) statements -> . statements NEWLINE statement
    (142) statements -> . statement
    (143) statements -> .
    (89) statement -> . expression
    (90) statement -> . var_s
    (91) statement -> . flow_s
    (92) statement -> . assert_s
    (93) statement -> . block_s
    (94) statement -> . import_s
    (95) statement -> . assignment
    (96) statement -> . declaration
    (88) expression -> . test_or
    (99) var_s -> . DEL many_idents
    (100) var_s -> . EXTERN many_idents
    (103) flow_s -> . BREAK flow_item
    (104) flow_s -> . CONTINUE flow_item
    (105) flow_s -> . RETURN comma_list
    (106) flow_s -> . RETURN comma_list ,
    (107) flow_s -> . THROW flow_item
    (108) flow_s -> . YIELD comma_list
    (109) flow_s -> . YIELD comma_list ,
    (119) assert_s -> . ASSERT expression
    (120) assert_s -> . ASSERT expression , expression
    (121) block_s -> . if_s
    (122) block_s -> . while_s
    (123) block_s -> . for_s
    (124) block_s -> . try_s
    (114) import_s -> . IMPORT import_items
    (115) import_s -> . IMPORT import_items AS ident
    (97) assignment -> . many_idents EQOP comma_list
    (98) declaration -> . ident assignment
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (125) if_s -> . if_if if_elifs else
    (132) while_s -> . WHILE expression block else
    (133) while_s -> . WHILE block else
    (134) for_s -> . FOR many_idents IN comma_list block else
    (135) try_s -> . try_try try_catch else
    (101) many_idents -> . many_idents , ident
    (102) many_idents -> . ident
    (7) ident -> . IDENT
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (126) if_if -> . IF expression block
    (136) try_try -> . TRY block
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }

    NEWLINE         reduce using rule 143 (statements -> .)
    $end            reduce using rule 143 (statements -> .)
    DEL             shift and go to state 10
    EXTERN          shift and go to state 33
    BREAK           shift and go to state 44
    CONTINUE        shift and go to state 22
    RETURN          shift and go to state 9
    THROW           shift and go to state 61
    YIELD           shift and go to state 55
    ASSERT          shift and go to state 48
    IMPORT          shift and go to state 6
    WHILE           shift and go to state 32
    FOR             shift and go to state 16
    IDENT           shift and go to state 15
    IF              shift and go to state 57
    TRY             shift and go to state 18
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56


    flow_s                         shift and go to state 27
    primitive                      shift and go to state 28
    statements                     shift and go to state 29
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_exp                       shift and go to state 47
    while_s                        shift and go to state 49
    test_comp                      shift and go to state 34
    import_s                       shift and go to state 35
    try_s                          shift and go to state 1
    for_s                          shift and go to state 2
    test_type                      shift and go to state 36
    assert_s                       shift and go to state 12
    if_s                           shift and go to state 13
    if_if                          shift and go to state 4
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    statement                      shift and go to state 38
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    assignment                     shift and go to state 54
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    many_idents                    shift and go to state 59
    test_attr                      shift and go to state 58
    declaration                    shift and go to state 41
    test_not                       shift and go to state 43
    try_try                        shift and go to state 26
    ident                          shift and go to state 42
    test_in                        shift and go to state 40
    expression                     shift and go to state 25
    block_s                        shift and go to state 46
    test_pm                        shift and go to state 60
    var_s                          shift and go to state 8

state 1

    (124) block_s -> try_s .

    NEWLINE         reduce using rule 124 (block_s -> try_s .)
    $end            reduce using rule 124 (block_s -> try_s .)
    }               reduce using rule 124 (block_s -> try_s .)



state 2

    (123) block_s -> for_s .

    NEWLINE         reduce using rule 123 (block_s -> for_s .)
    $end            reduce using rule 123 (block_s -> for_s .)
    }               reduce using rule 123 (block_s -> for_s .)



state 3

    (87) test_basis -> ( . expression )
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 63

state 4

    (125) if_s -> if_if . if_elifs else
    (127) if_elifs -> . ELIF expression block if_elifs
    (128) if_elifs -> .

    ELIF            shift and go to state 64
    ELSE            reduce using rule 128 (if_elifs -> .)
    NEWLINE         reduce using rule 128 (if_elifs -> .)
    $end            reduce using rule 128 (if_elifs -> .)
    }               reduce using rule 128 (if_elifs -> .)


    if_elifs                       shift and go to state 65

state 5

    (54) test_mdmf -> test_un .
    (55) test_un -> test_un . PLUSPLUS
    (56) test_un -> test_un . MINUSMINUS

    *               reduce using rule 54 (test_mdmf -> test_un .)
    /               reduce using rule 54 (test_mdmf -> test_un .)
    SLASHSLASH      reduce using rule 54 (test_mdmf -> test_un .)
    MOD             reduce using rule 54 (test_mdmf -> test_un .)
    +               reduce using rule 54 (test_mdmf -> test_un .)
    -               reduce using rule 54 (test_mdmf -> test_un .)
    LTLT            reduce using rule 54 (test_mdmf -> test_un .)
    GTGT            reduce using rule 54 (test_mdmf -> test_un .)
    <               reduce using rule 54 (test_mdmf -> test_un .)
    LE              reduce using rule 54 (test_mdmf -> test_un .)
    >               reduce using rule 54 (test_mdmf -> test_un .)
    GE              reduce using rule 54 (test_mdmf -> test_un .)
    NE              reduce using rule 54 (test_mdmf -> test_un .)
    EQ              reduce using rule 54 (test_mdmf -> test_un .)
    IS              reduce using rule 54 (test_mdmf -> test_un .)
    IN              reduce using rule 54 (test_mdmf -> test_un .)
    NOT             reduce using rule 54 (test_mdmf -> test_un .)
    |               reduce using rule 54 (test_mdmf -> test_un .)
    AND             reduce using rule 54 (test_mdmf -> test_un .)
    OR              reduce using rule 54 (test_mdmf -> test_un .)
    ,               reduce using rule 54 (test_mdmf -> test_un .)
    {               reduce using rule 54 (test_mdmf -> test_un .)
    NEWLINE         reduce using rule 54 (test_mdmf -> test_un .)
    $end            reduce using rule 54 (test_mdmf -> test_un .)
    )               reduce using rule 54 (test_mdmf -> test_un .)
    }               reduce using rule 54 (test_mdmf -> test_un .)
    ]               reduce using rule 54 (test_mdmf -> test_un .)
    AS              reduce using rule 54 (test_mdmf -> test_un .)
    :               reduce using rule 54 (test_mdmf -> test_un .)
    PLUSPLUS        shift and go to state 66
    MINUSMINUS      shift and go to state 67



state 6

    (114) import_s -> IMPORT . import_items
    (115) import_s -> IMPORT . import_items AS ident
    (116) import_items -> . ident . import_items
    (117) import_items -> . ident
    (118) import_items -> . *
    (7) ident -> . IDENT

    *               shift and go to state 70
    IDENT           shift and go to state 15


    import_items                   shift and go to state 69
    ident                          shift and go to state 68

state 7

    (4) primitive -> NIL .

    [               reduce using rule 4 (primitive -> NIL .)
    .               reduce using rule 4 (primitive -> NIL .)
    ^               reduce using rule 4 (primitive -> NIL .)
    (               reduce using rule 4 (primitive -> NIL .)
    PLUSPLUS        reduce using rule 4 (primitive -> NIL .)
    MINUSMINUS      reduce using rule 4 (primitive -> NIL .)
    *               reduce using rule 4 (primitive -> NIL .)
    /               reduce using rule 4 (primitive -> NIL .)
    SLASHSLASH      reduce using rule 4 (primitive -> NIL .)
    MOD             reduce using rule 4 (primitive -> NIL .)
    +               reduce using rule 4 (primitive -> NIL .)
    -               reduce using rule 4 (primitive -> NIL .)
    LTLT            reduce using rule 4 (primitive -> NIL .)
    GTGT            reduce using rule 4 (primitive -> NIL .)
    <               reduce using rule 4 (primitive -> NIL .)
    LE              reduce using rule 4 (primitive -> NIL .)
    >               reduce using rule 4 (primitive -> NIL .)
    GE              reduce using rule 4 (primitive -> NIL .)
    NE              reduce using rule 4 (primitive -> NIL .)
    EQ              reduce using rule 4 (primitive -> NIL .)
    IS              reduce using rule 4 (primitive -> NIL .)
    IN              reduce using rule 4 (primitive -> NIL .)
    NOT             reduce using rule 4 (primitive -> NIL .)
    |               reduce using rule 4 (primitive -> NIL .)
    AND             reduce using rule 4 (primitive -> NIL .)
    OR              reduce using rule 4 (primitive -> NIL .)
    ,               reduce using rule 4 (primitive -> NIL .)
    {               reduce using rule 4 (primitive -> NIL .)
    NEWLINE         reduce using rule 4 (primitive -> NIL .)
    $end            reduce using rule 4 (primitive -> NIL .)
    )               reduce using rule 4 (primitive -> NIL .)
    }               reduce using rule 4 (primitive -> NIL .)
    ]               reduce using rule 4 (primitive -> NIL .)
    AS              reduce using rule 4 (primitive -> NIL .)
    :               reduce using rule 4 (primitive -> NIL .)



state 8

    (90) statement -> var_s .

    NEWLINE         reduce using rule 90 (statement -> var_s .)
    $end            reduce using rule 90 (statement -> var_s .)
    }               reduce using rule 90 (statement -> var_s .)



state 9

    (105) flow_s -> RETURN . comma_list
    (106) flow_s -> RETURN . comma_list ,
    (112) comma_list -> . comma_list , expression
    (113) comma_list -> . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    comma_list                     shift and go to state 71
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 72

state 10

    (99) var_s -> DEL . many_idents
    (101) many_idents -> . many_idents , ident
    (102) many_idents -> . ident
    (7) ident -> . IDENT

    IDENT           shift and go to state 15


    many_idents                    shift and go to state 73
    ident                          shift and go to state 74

state 11

    (58) test_un -> + . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_sub                       shift and go to state 52
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 75

state 12

    (92) statement -> assert_s .

    NEWLINE         reduce using rule 92 (statement -> assert_s .)
    $end            reduce using rule 92 (statement -> assert_s .)
    }               reduce using rule 92 (statement -> assert_s .)



state 13

    (121) block_s -> if_s .

    NEWLINE         reduce using rule 121 (block_s -> if_s .)
    $end            reduce using rule 121 (block_s -> if_s .)
    }               reduce using rule 121 (block_s -> if_s .)



state 14

    (88) expression -> test_or .
    (24) test_or -> test_or . OR test_and

    NEWLINE         reduce using rule 88 (expression -> test_or .)
    $end            reduce using rule 88 (expression -> test_or .)
    }               reduce using rule 88 (expression -> test_or .)
    ]               reduce using rule 88 (expression -> test_or .)
    ,               reduce using rule 88 (expression -> test_or .)
    AS              reduce using rule 88 (expression -> test_or .)
    {               reduce using rule 88 (expression -> test_or .)
    )               reduce using rule 88 (expression -> test_or .)
    :               reduce using rule 88 (expression -> test_or .)
    OR              shift and go to state 76



state 15

    (7) ident -> IDENT .

    [               reduce using rule 7 (ident -> IDENT .)
    .               reduce using rule 7 (ident -> IDENT .)
    ^               reduce using rule 7 (ident -> IDENT .)
    (               reduce using rule 7 (ident -> IDENT .)
    PLUSPLUS        reduce using rule 7 (ident -> IDENT .)
    MINUSMINUS      reduce using rule 7 (ident -> IDENT .)
    *               reduce using rule 7 (ident -> IDENT .)
    /               reduce using rule 7 (ident -> IDENT .)
    SLASHSLASH      reduce using rule 7 (ident -> IDENT .)
    MOD             reduce using rule 7 (ident -> IDENT .)
    +               reduce using rule 7 (ident -> IDENT .)
    -               reduce using rule 7 (ident -> IDENT .)
    LTLT            reduce using rule 7 (ident -> IDENT .)
    GTGT            reduce using rule 7 (ident -> IDENT .)
    <               reduce using rule 7 (ident -> IDENT .)
    LE              reduce using rule 7 (ident -> IDENT .)
    >               reduce using rule 7 (ident -> IDENT .)
    GE              reduce using rule 7 (ident -> IDENT .)
    NE              reduce using rule 7 (ident -> IDENT .)
    EQ              reduce using rule 7 (ident -> IDENT .)
    IS              reduce using rule 7 (ident -> IDENT .)
    IN              reduce using rule 7 (ident -> IDENT .)
    NOT             reduce using rule 7 (ident -> IDENT .)
    |               reduce using rule 7 (ident -> IDENT .)
    AND             reduce using rule 7 (ident -> IDENT .)
    OR              reduce using rule 7 (ident -> IDENT .)
    NEWLINE         reduce using rule 7 (ident -> IDENT .)
    $end            reduce using rule 7 (ident -> IDENT .)
    )               reduce using rule 7 (ident -> IDENT .)
    ,               reduce using rule 7 (ident -> IDENT .)
    }               reduce using rule 7 (ident -> IDENT .)
    ]               reduce using rule 7 (ident -> IDENT .)
    {               reduce using rule 7 (ident -> IDENT .)
    AS              reduce using rule 7 (ident -> IDENT .)
    :               reduce using rule 7 (ident -> IDENT .)
    =               reduce using rule 7 (ident -> IDENT .)
    IDENT           reduce using rule 7 (ident -> IDENT .)
    EQOP            reduce using rule 7 (ident -> IDENT .)



state 16

    (134) for_s -> FOR . many_idents IN comma_list block else
    (101) many_idents -> . many_idents , ident
    (102) many_idents -> . ident
    (7) ident -> . IDENT

    IDENT           shift and go to state 15


    many_idents                    shift and go to state 77
    ident                          shift and go to state 74

state 17

    (60) test_exp -> test_call . ^ test_exp
    (61) test_exp -> test_call .
    (62) test_call -> test_call . ( arglist )
    (63) test_call -> test_call . ( arglist , )

    ^               shift and go to state 79
    PLUSPLUS        reduce using rule 61 (test_exp -> test_call .)
    MINUSMINUS      reduce using rule 61 (test_exp -> test_call .)
    *               reduce using rule 61 (test_exp -> test_call .)
    /               reduce using rule 61 (test_exp -> test_call .)
    SLASHSLASH      reduce using rule 61 (test_exp -> test_call .)
    MOD             reduce using rule 61 (test_exp -> test_call .)
    +               reduce using rule 61 (test_exp -> test_call .)
    -               reduce using rule 61 (test_exp -> test_call .)
    LTLT            reduce using rule 61 (test_exp -> test_call .)
    GTGT            reduce using rule 61 (test_exp -> test_call .)
    <               reduce using rule 61 (test_exp -> test_call .)
    LE              reduce using rule 61 (test_exp -> test_call .)
    >               reduce using rule 61 (test_exp -> test_call .)
    GE              reduce using rule 61 (test_exp -> test_call .)
    NE              reduce using rule 61 (test_exp -> test_call .)
    EQ              reduce using rule 61 (test_exp -> test_call .)
    IS              reduce using rule 61 (test_exp -> test_call .)
    IN              reduce using rule 61 (test_exp -> test_call .)
    NOT             reduce using rule 61 (test_exp -> test_call .)
    |               reduce using rule 61 (test_exp -> test_call .)
    AND             reduce using rule 61 (test_exp -> test_call .)
    OR              reduce using rule 61 (test_exp -> test_call .)
    NEWLINE         reduce using rule 61 (test_exp -> test_call .)
    $end            reduce using rule 61 (test_exp -> test_call .)
    )               reduce using rule 61 (test_exp -> test_call .)
    ,               reduce using rule 61 (test_exp -> test_call .)
    }               reduce using rule 61 (test_exp -> test_call .)
    ]               reduce using rule 61 (test_exp -> test_call .)
    {               reduce using rule 61 (test_exp -> test_call .)
    AS              reduce using rule 61 (test_exp -> test_call .)
    :               reduce using rule 61 (test_exp -> test_call .)
    (               shift and go to state 78



state 18

    (136) try_try -> TRY . block
    (131) block -> . { statements }

    {               shift and go to state 80


    block                          shift and go to state 81

state 19

    (8) literal -> [ . list_items ]
    (9) literal -> [ . list_items , ]
    (10) literal -> [ . ]
    (11) literal -> [ . hash_items ]
    (12) literal -> [ . hash_items , ]
    (18) list_items -> . list_items , expression
    (19) list_items -> . expression
    (20) hash_items -> . hash_items , primitive : expression
    (21) hash_items -> . hash_items , ident : expression
    (22) hash_items -> . primitive : expression
    (23) hash_items -> . ident : expression
    (88) expression -> . test_or
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (7) ident -> . IDENT
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }

    ]               shift and go to state 85
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    IDENT           shift and go to state 15
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    [               shift and go to state 19
    {               shift and go to state 56


    primitive                      shift and go to state 82
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    hash_items                     shift and go to state 83
    test_comp                      shift and go to state 34
    list_items                     shift and go to state 84
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 86
    test_pm                        shift and go to state 60
    expression                     shift and go to state 87

state 20

    (1) primitive -> DEC .

    [               reduce using rule 1 (primitive -> DEC .)
    .               reduce using rule 1 (primitive -> DEC .)
    ^               reduce using rule 1 (primitive -> DEC .)
    (               reduce using rule 1 (primitive -> DEC .)
    PLUSPLUS        reduce using rule 1 (primitive -> DEC .)
    MINUSMINUS      reduce using rule 1 (primitive -> DEC .)
    *               reduce using rule 1 (primitive -> DEC .)
    /               reduce using rule 1 (primitive -> DEC .)
    SLASHSLASH      reduce using rule 1 (primitive -> DEC .)
    MOD             reduce using rule 1 (primitive -> DEC .)
    +               reduce using rule 1 (primitive -> DEC .)
    -               reduce using rule 1 (primitive -> DEC .)
    LTLT            reduce using rule 1 (primitive -> DEC .)
    GTGT            reduce using rule 1 (primitive -> DEC .)
    <               reduce using rule 1 (primitive -> DEC .)
    LE              reduce using rule 1 (primitive -> DEC .)
    >               reduce using rule 1 (primitive -> DEC .)
    GE              reduce using rule 1 (primitive -> DEC .)
    NE              reduce using rule 1 (primitive -> DEC .)
    EQ              reduce using rule 1 (primitive -> DEC .)
    IS              reduce using rule 1 (primitive -> DEC .)
    IN              reduce using rule 1 (primitive -> DEC .)
    NOT             reduce using rule 1 (primitive -> DEC .)
    |               reduce using rule 1 (primitive -> DEC .)
    AND             reduce using rule 1 (primitive -> DEC .)
    OR              reduce using rule 1 (primitive -> DEC .)
    ,               reduce using rule 1 (primitive -> DEC .)
    {               reduce using rule 1 (primitive -> DEC .)
    NEWLINE         reduce using rule 1 (primitive -> DEC .)
    $end            reduce using rule 1 (primitive -> DEC .)
    )               reduce using rule 1 (primitive -> DEC .)
    }               reduce using rule 1 (primitive -> DEC .)
    ]               reduce using rule 1 (primitive -> DEC .)
    AS              reduce using rule 1 (primitive -> DEC .)
    :               reduce using rule 1 (primitive -> DEC .)



state 21

    (3) primitive -> INT .

    [               reduce using rule 3 (primitive -> INT .)
    .               reduce using rule 3 (primitive -> INT .)
    ^               reduce using rule 3 (primitive -> INT .)
    (               reduce using rule 3 (primitive -> INT .)
    PLUSPLUS        reduce using rule 3 (primitive -> INT .)
    MINUSMINUS      reduce using rule 3 (primitive -> INT .)
    *               reduce using rule 3 (primitive -> INT .)
    /               reduce using rule 3 (primitive -> INT .)
    SLASHSLASH      reduce using rule 3 (primitive -> INT .)
    MOD             reduce using rule 3 (primitive -> INT .)
    +               reduce using rule 3 (primitive -> INT .)
    -               reduce using rule 3 (primitive -> INT .)
    LTLT            reduce using rule 3 (primitive -> INT .)
    GTGT            reduce using rule 3 (primitive -> INT .)
    <               reduce using rule 3 (primitive -> INT .)
    LE              reduce using rule 3 (primitive -> INT .)
    >               reduce using rule 3 (primitive -> INT .)
    GE              reduce using rule 3 (primitive -> INT .)
    NE              reduce using rule 3 (primitive -> INT .)
    EQ              reduce using rule 3 (primitive -> INT .)
    IS              reduce using rule 3 (primitive -> INT .)
    IN              reduce using rule 3 (primitive -> INT .)
    NOT             reduce using rule 3 (primitive -> INT .)
    |               reduce using rule 3 (primitive -> INT .)
    AND             reduce using rule 3 (primitive -> INT .)
    OR              reduce using rule 3 (primitive -> INT .)
    ,               reduce using rule 3 (primitive -> INT .)
    {               reduce using rule 3 (primitive -> INT .)
    NEWLINE         reduce using rule 3 (primitive -> INT .)
    $end            reduce using rule 3 (primitive -> INT .)
    )               reduce using rule 3 (primitive -> INT .)
    }               reduce using rule 3 (primitive -> INT .)
    ]               reduce using rule 3 (primitive -> INT .)
    AS              reduce using rule 3 (primitive -> INT .)
    :               reduce using rule 3 (primitive -> INT .)



state 22

    (104) flow_s -> CONTINUE . flow_item
    (110) flow_item -> . expression
    (111) flow_item -> .
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NEWLINE         reduce using rule 111 (flow_item -> .)
    $end            reduce using rule 111 (flow_item -> .)
    }               reduce using rule 111 (flow_item -> .)
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    flow_item                      shift and go to state 88
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 89

state 23

    (28) test_not -> NOT . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    test_type                      shift and go to state 36
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 90
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_comp                      shift and go to state 34
    test_sub                       shift and go to state 52

state 24

    (6) primitive -> INF .

    [               reduce using rule 6 (primitive -> INF .)
    .               reduce using rule 6 (primitive -> INF .)
    ^               reduce using rule 6 (primitive -> INF .)
    (               reduce using rule 6 (primitive -> INF .)
    PLUSPLUS        reduce using rule 6 (primitive -> INF .)
    MINUSMINUS      reduce using rule 6 (primitive -> INF .)
    *               reduce using rule 6 (primitive -> INF .)
    /               reduce using rule 6 (primitive -> INF .)
    SLASHSLASH      reduce using rule 6 (primitive -> INF .)
    MOD             reduce using rule 6 (primitive -> INF .)
    +               reduce using rule 6 (primitive -> INF .)
    -               reduce using rule 6 (primitive -> INF .)
    LTLT            reduce using rule 6 (primitive -> INF .)
    GTGT            reduce using rule 6 (primitive -> INF .)
    <               reduce using rule 6 (primitive -> INF .)
    LE              reduce using rule 6 (primitive -> INF .)
    >               reduce using rule 6 (primitive -> INF .)
    GE              reduce using rule 6 (primitive -> INF .)
    NE              reduce using rule 6 (primitive -> INF .)
    EQ              reduce using rule 6 (primitive -> INF .)
    IS              reduce using rule 6 (primitive -> INF .)
    IN              reduce using rule 6 (primitive -> INF .)
    NOT             reduce using rule 6 (primitive -> INF .)
    |               reduce using rule 6 (primitive -> INF .)
    AND             reduce using rule 6 (primitive -> INF .)
    OR              reduce using rule 6 (primitive -> INF .)
    ,               reduce using rule 6 (primitive -> INF .)
    {               reduce using rule 6 (primitive -> INF .)
    NEWLINE         reduce using rule 6 (primitive -> INF .)
    $end            reduce using rule 6 (primitive -> INF .)
    )               reduce using rule 6 (primitive -> INF .)
    }               reduce using rule 6 (primitive -> INF .)
    ]               reduce using rule 6 (primitive -> INF .)
    AS              reduce using rule 6 (primitive -> INF .)
    :               reduce using rule 6 (primitive -> INF .)



state 25

    (89) statement -> expression .

    NEWLINE         reduce using rule 89 (statement -> expression .)
    $end            reduce using rule 89 (statement -> expression .)
    }               reduce using rule 89 (statement -> expression .)



state 26

    (135) try_s -> try_try . try_catch else
    (137) try_catch -> . CATCH expression block try_catch
    (138) try_catch -> . CATCH expression AS ident block try_catch
    (139) try_catch -> .

    CATCH           shift and go to state 92
    ELSE            reduce using rule 139 (try_catch -> .)
    NEWLINE         reduce using rule 139 (try_catch -> .)
    $end            reduce using rule 139 (try_catch -> .)
    }               reduce using rule 139 (try_catch -> .)


    try_catch                      shift and go to state 91

state 27

    (91) statement -> flow_s .

    NEWLINE         reduce using rule 91 (statement -> flow_s .)
    $end            reduce using rule 91 (statement -> flow_s .)
    }               reduce using rule 91 (statement -> flow_s .)



state 28

    (84) test_basis -> primitive .

    [               reduce using rule 84 (test_basis -> primitive .)
    .               reduce using rule 84 (test_basis -> primitive .)
    ^               reduce using rule 84 (test_basis -> primitive .)
    (               reduce using rule 84 (test_basis -> primitive .)
    PLUSPLUS        reduce using rule 84 (test_basis -> primitive .)
    MINUSMINUS      reduce using rule 84 (test_basis -> primitive .)
    *               reduce using rule 84 (test_basis -> primitive .)
    /               reduce using rule 84 (test_basis -> primitive .)
    SLASHSLASH      reduce using rule 84 (test_basis -> primitive .)
    MOD             reduce using rule 84 (test_basis -> primitive .)
    +               reduce using rule 84 (test_basis -> primitive .)
    -               reduce using rule 84 (test_basis -> primitive .)
    LTLT            reduce using rule 84 (test_basis -> primitive .)
    GTGT            reduce using rule 84 (test_basis -> primitive .)
    <               reduce using rule 84 (test_basis -> primitive .)
    LE              reduce using rule 84 (test_basis -> primitive .)
    >               reduce using rule 84 (test_basis -> primitive .)
    GE              reduce using rule 84 (test_basis -> primitive .)
    NE              reduce using rule 84 (test_basis -> primitive .)
    EQ              reduce using rule 84 (test_basis -> primitive .)
    IS              reduce using rule 84 (test_basis -> primitive .)
    IN              reduce using rule 84 (test_basis -> primitive .)
    NOT             reduce using rule 84 (test_basis -> primitive .)
    |               reduce using rule 84 (test_basis -> primitive .)
    AND             reduce using rule 84 (test_basis -> primitive .)
    OR              reduce using rule 84 (test_basis -> primitive .)
    NEWLINE         reduce using rule 84 (test_basis -> primitive .)
    $end            reduce using rule 84 (test_basis -> primitive .)
    )               reduce using rule 84 (test_basis -> primitive .)
    ,               reduce using rule 84 (test_basis -> primitive .)
    }               reduce using rule 84 (test_basis -> primitive .)
    ]               reduce using rule 84 (test_basis -> primitive .)
    {               reduce using rule 84 (test_basis -> primitive .)
    AS              reduce using rule 84 (test_basis -> primitive .)
    :               reduce using rule 84 (test_basis -> primitive .)



state 29

    (0) S' -> statements .
    (140) statements -> statements . NEWLINE
    (141) statements -> statements . NEWLINE statement

    NEWLINE         shift and go to state 93



state 30

    (25) test_or -> test_and .
    (26) test_and -> test_and . AND test_not

    OR              reduce using rule 25 (test_or -> test_and .)
    ]               reduce using rule 25 (test_or -> test_and .)
    ,               reduce using rule 25 (test_or -> test_and .)
    }               reduce using rule 25 (test_or -> test_and .)
    NEWLINE         reduce using rule 25 (test_or -> test_and .)
    $end            reduce using rule 25 (test_or -> test_and .)
    )               reduce using rule 25 (test_or -> test_and .)
    :               reduce using rule 25 (test_or -> test_and .)
    {               reduce using rule 25 (test_or -> test_and .)
    AS              reduce using rule 25 (test_or -> test_and .)
    AND             shift and go to state 94



state 31

    (49) test_pm -> test_mdmf .
    (50) test_mdmf -> test_mdmf . * test_un
    (51) test_mdmf -> test_mdmf . / test_un
    (52) test_mdmf -> test_mdmf . SLASHSLASH test_un
    (53) test_mdmf -> test_mdmf . MOD test_un

    +               reduce using rule 49 (test_pm -> test_mdmf .)
    -               reduce using rule 49 (test_pm -> test_mdmf .)
    LTLT            reduce using rule 49 (test_pm -> test_mdmf .)
    GTGT            reduce using rule 49 (test_pm -> test_mdmf .)
    <               reduce using rule 49 (test_pm -> test_mdmf .)
    LE              reduce using rule 49 (test_pm -> test_mdmf .)
    >               reduce using rule 49 (test_pm -> test_mdmf .)
    GE              reduce using rule 49 (test_pm -> test_mdmf .)
    NE              reduce using rule 49 (test_pm -> test_mdmf .)
    EQ              reduce using rule 49 (test_pm -> test_mdmf .)
    IS              reduce using rule 49 (test_pm -> test_mdmf .)
    IN              reduce using rule 49 (test_pm -> test_mdmf .)
    NOT             reduce using rule 49 (test_pm -> test_mdmf .)
    |               reduce using rule 49 (test_pm -> test_mdmf .)
    AND             reduce using rule 49 (test_pm -> test_mdmf .)
    OR              reduce using rule 49 (test_pm -> test_mdmf .)
    NEWLINE         reduce using rule 49 (test_pm -> test_mdmf .)
    $end            reduce using rule 49 (test_pm -> test_mdmf .)
    }               reduce using rule 49 (test_pm -> test_mdmf .)
    ]               reduce using rule 49 (test_pm -> test_mdmf .)
    ,               reduce using rule 49 (test_pm -> test_mdmf .)
    )               reduce using rule 49 (test_pm -> test_mdmf .)
    {               reduce using rule 49 (test_pm -> test_mdmf .)
    AS              reduce using rule 49 (test_pm -> test_mdmf .)
    :               reduce using rule 49 (test_pm -> test_mdmf .)
    *               shift and go to state 96
    /               shift and go to state 97
    SLASHSLASH      shift and go to state 95
    MOD             shift and go to state 98



state 32

    (132) while_s -> WHILE . expression block else
    (133) while_s -> WHILE . block else
    (88) expression -> . test_or
    (131) block -> . { statements }
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    {               shift and go to state 100
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_exp                       shift and go to state 47
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    ident                          shift and go to state 62
    test_not                       shift and go to state 43
    test_attr                      shift and go to state 58
    test_pm                        shift and go to state 60
    expression                     shift and go to state 99
    block                          shift and go to state 101

state 33

    (100) var_s -> EXTERN . many_idents
    (101) many_idents -> . many_idents , ident
    (102) many_idents -> . ident
    (7) ident -> . IDENT

    IDENT           shift and go to state 15


    many_idents                    shift and go to state 102
    ident                          shift and go to state 74

state 34

    (36) test_type -> test_comp .
    (37) test_comp -> test_comp . < test_io
    (38) test_comp -> test_comp . LE test_io
    (39) test_comp -> test_comp . > test_io
    (40) test_comp -> test_comp . GE test_io
    (41) test_comp -> test_comp . NE test_io
    (42) test_comp -> test_comp . EQ test_io

    IS              reduce using rule 36 (test_type -> test_comp .)
    IN              reduce using rule 36 (test_type -> test_comp .)
    NOT             reduce using rule 36 (test_type -> test_comp .)
    |               reduce using rule 36 (test_type -> test_comp .)
    AND             reduce using rule 36 (test_type -> test_comp .)
    OR              reduce using rule 36 (test_type -> test_comp .)
    :               reduce using rule 36 (test_type -> test_comp .)
    ]               reduce using rule 36 (test_type -> test_comp .)
    ,               reduce using rule 36 (test_type -> test_comp .)
    }               reduce using rule 36 (test_type -> test_comp .)
    NEWLINE         reduce using rule 36 (test_type -> test_comp .)
    {               reduce using rule 36 (test_type -> test_comp .)
    AS              reduce using rule 36 (test_type -> test_comp .)
    $end            reduce using rule 36 (test_type -> test_comp .)
    )               reduce using rule 36 (test_type -> test_comp .)
    <               shift and go to state 107
    LE              shift and go to state 103
    >               shift and go to state 108
    GE              shift and go to state 105
    NE              shift and go to state 104
    EQ              shift and go to state 106



state 35

    (94) statement -> import_s .

    NEWLINE         reduce using rule 94 (statement -> import_s .)
    $end            reduce using rule 94 (statement -> import_s .)
    }               reduce using rule 94 (statement -> import_s .)



state 36

    (33) test_in -> test_type .
    (34) test_type -> test_type . IS test_comp
    (35) test_type -> test_type . IS NOT test_comp

    IN              reduce using rule 33 (test_in -> test_type .)
    NOT             reduce using rule 33 (test_in -> test_type .)
    |               reduce using rule 33 (test_in -> test_type .)
    AND             reduce using rule 33 (test_in -> test_type .)
    OR              reduce using rule 33 (test_in -> test_type .)
    ,               reduce using rule 33 (test_in -> test_type .)
    NEWLINE         reduce using rule 33 (test_in -> test_type .)
    $end            reduce using rule 33 (test_in -> test_type .)
    }               reduce using rule 33 (test_in -> test_type .)
    {               reduce using rule 33 (test_in -> test_type .)
    )               reduce using rule 33 (test_in -> test_type .)
    ]               reduce using rule 33 (test_in -> test_type .)
    :               reduce using rule 33 (test_in -> test_type .)
    AS              reduce using rule 33 (test_in -> test_type .)
    IS              shift and go to state 109



state 37

    (85) test_basis -> literal .

    [               reduce using rule 85 (test_basis -> literal .)
    .               reduce using rule 85 (test_basis -> literal .)
    ^               reduce using rule 85 (test_basis -> literal .)
    (               reduce using rule 85 (test_basis -> literal .)
    PLUSPLUS        reduce using rule 85 (test_basis -> literal .)
    MINUSMINUS      reduce using rule 85 (test_basis -> literal .)
    *               reduce using rule 85 (test_basis -> literal .)
    /               reduce using rule 85 (test_basis -> literal .)
    SLASHSLASH      reduce using rule 85 (test_basis -> literal .)
    MOD             reduce using rule 85 (test_basis -> literal .)
    +               reduce using rule 85 (test_basis -> literal .)
    -               reduce using rule 85 (test_basis -> literal .)
    LTLT            reduce using rule 85 (test_basis -> literal .)
    GTGT            reduce using rule 85 (test_basis -> literal .)
    <               reduce using rule 85 (test_basis -> literal .)
    LE              reduce using rule 85 (test_basis -> literal .)
    >               reduce using rule 85 (test_basis -> literal .)
    GE              reduce using rule 85 (test_basis -> literal .)
    NE              reduce using rule 85 (test_basis -> literal .)
    EQ              reduce using rule 85 (test_basis -> literal .)
    IS              reduce using rule 85 (test_basis -> literal .)
    IN              reduce using rule 85 (test_basis -> literal .)
    NOT             reduce using rule 85 (test_basis -> literal .)
    |               reduce using rule 85 (test_basis -> literal .)
    AND             reduce using rule 85 (test_basis -> literal .)
    OR              reduce using rule 85 (test_basis -> literal .)
    NEWLINE         reduce using rule 85 (test_basis -> literal .)
    $end            reduce using rule 85 (test_basis -> literal .)
    )               reduce using rule 85 (test_basis -> literal .)
    ,               reduce using rule 85 (test_basis -> literal .)
    }               reduce using rule 85 (test_basis -> literal .)
    ]               reduce using rule 85 (test_basis -> literal .)
    {               reduce using rule 85 (test_basis -> literal .)
    AS              reduce using rule 85 (test_basis -> literal .)
    :               reduce using rule 85 (test_basis -> literal .)



state 38

    (142) statements -> statement .

    }               reduce using rule 142 (statements -> statement .)
    NEWLINE         reduce using rule 142 (statements -> statement .)
    $end            reduce using rule 142 (statements -> statement .)



state 39

    (43) test_comp -> test_io .
    (44) test_io -> test_io . LTLT test_pm
    (45) test_io -> test_io . GTGT test_pm

    <               reduce using rule 43 (test_comp -> test_io .)
    LE              reduce using rule 43 (test_comp -> test_io .)
    >               reduce using rule 43 (test_comp -> test_io .)
    GE              reduce using rule 43 (test_comp -> test_io .)
    NE              reduce using rule 43 (test_comp -> test_io .)
    EQ              reduce using rule 43 (test_comp -> test_io .)
    IS              reduce using rule 43 (test_comp -> test_io .)
    IN              reduce using rule 43 (test_comp -> test_io .)
    NOT             reduce using rule 43 (test_comp -> test_io .)
    |               reduce using rule 43 (test_comp -> test_io .)
    AND             reduce using rule 43 (test_comp -> test_io .)
    OR              reduce using rule 43 (test_comp -> test_io .)
    }               reduce using rule 43 (test_comp -> test_io .)
    ,               reduce using rule 43 (test_comp -> test_io .)
    NEWLINE         reduce using rule 43 (test_comp -> test_io .)
    $end            reduce using rule 43 (test_comp -> test_io .)
    {               reduce using rule 43 (test_comp -> test_io .)
    )               reduce using rule 43 (test_comp -> test_io .)
    ]               reduce using rule 43 (test_comp -> test_io .)
    AS              reduce using rule 43 (test_comp -> test_io .)
    :               reduce using rule 43 (test_comp -> test_io .)
    LTLT            shift and go to state 111
    GTGT            shift and go to state 110



state 40

    (29) test_not -> test_in .
    (30) test_in -> test_in . IN test_type
    (31) test_in -> test_in . NOT IN test_type
    (32) test_in -> test_in . | test_type

    AND             reduce using rule 29 (test_not -> test_in .)
    OR              reduce using rule 29 (test_not -> test_in .)
    :               reduce using rule 29 (test_not -> test_in .)
    ]               reduce using rule 29 (test_not -> test_in .)
    ,               reduce using rule 29 (test_not -> test_in .)
    NEWLINE         reduce using rule 29 (test_not -> test_in .)
    $end            reduce using rule 29 (test_not -> test_in .)
    }               reduce using rule 29 (test_not -> test_in .)
    )               reduce using rule 29 (test_not -> test_in .)
    {               reduce using rule 29 (test_not -> test_in .)
    AS              reduce using rule 29 (test_not -> test_in .)
    IN              shift and go to state 114
    NOT             shift and go to state 112
    |               shift and go to state 113



state 41

    (96) statement -> declaration .

    NEWLINE         reduce using rule 96 (statement -> declaration .)
    $end            reduce using rule 96 (statement -> declaration .)
    }               reduce using rule 96 (statement -> declaration .)



state 42

    (98) declaration -> ident . assignment
    (102) many_idents -> ident .
    (86) test_basis -> ident .
    (97) assignment -> . many_idents EQOP comma_list
    (101) many_idents -> . many_idents , ident
    (102) many_idents -> . ident
    (7) ident -> . IDENT

    EQOP            reduce using rule 102 (many_idents -> ident .)
    ,               reduce using rule 102 (many_idents -> ident .)
    [               reduce using rule 86 (test_basis -> ident .)
    .               reduce using rule 86 (test_basis -> ident .)
    ^               reduce using rule 86 (test_basis -> ident .)
    (               reduce using rule 86 (test_basis -> ident .)
    PLUSPLUS        reduce using rule 86 (test_basis -> ident .)
    MINUSMINUS      reduce using rule 86 (test_basis -> ident .)
    *               reduce using rule 86 (test_basis -> ident .)
    /               reduce using rule 86 (test_basis -> ident .)
    SLASHSLASH      reduce using rule 86 (test_basis -> ident .)
    MOD             reduce using rule 86 (test_basis -> ident .)
    +               reduce using rule 86 (test_basis -> ident .)
    -               reduce using rule 86 (test_basis -> ident .)
    LTLT            reduce using rule 86 (test_basis -> ident .)
    GTGT            reduce using rule 86 (test_basis -> ident .)
    <               reduce using rule 86 (test_basis -> ident .)
    LE              reduce using rule 86 (test_basis -> ident .)
    >               reduce using rule 86 (test_basis -> ident .)
    GE              reduce using rule 86 (test_basis -> ident .)
    NE              reduce using rule 86 (test_basis -> ident .)
    EQ              reduce using rule 86 (test_basis -> ident .)
    IS              reduce using rule 86 (test_basis -> ident .)
    IN              reduce using rule 86 (test_basis -> ident .)
    NOT             reduce using rule 86 (test_basis -> ident .)
    |               reduce using rule 86 (test_basis -> ident .)
    AND             reduce using rule 86 (test_basis -> ident .)
    OR              reduce using rule 86 (test_basis -> ident .)
    NEWLINE         reduce using rule 86 (test_basis -> ident .)
    $end            reduce using rule 86 (test_basis -> ident .)
    }               reduce using rule 86 (test_basis -> ident .)
    IDENT           shift and go to state 15


    assignment                     shift and go to state 115
    many_idents                    shift and go to state 59
    ident                          shift and go to state 74

state 43

    (27) test_and -> test_not .

    AND             reduce using rule 27 (test_and -> test_not .)
    OR              reduce using rule 27 (test_and -> test_not .)
    ,               reduce using rule 27 (test_and -> test_not .)
    NEWLINE         reduce using rule 27 (test_and -> test_not .)
    $end            reduce using rule 27 (test_and -> test_not .)
    }               reduce using rule 27 (test_and -> test_not .)
    {               reduce using rule 27 (test_and -> test_not .)
    )               reduce using rule 27 (test_and -> test_not .)
    AS              reduce using rule 27 (test_and -> test_not .)
    :               reduce using rule 27 (test_and -> test_not .)
    ]               reduce using rule 27 (test_and -> test_not .)



state 44

    (103) flow_s -> BREAK . flow_item
    (110) flow_item -> . expression
    (111) flow_item -> .
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NEWLINE         reduce using rule 111 (flow_item -> .)
    $end            reduce using rule 111 (flow_item -> .)
    }               reduce using rule 111 (flow_item -> .)
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    flow_item                      shift and go to state 116
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 89

state 45

    (5) primitive -> BOOL .

    [               reduce using rule 5 (primitive -> BOOL .)
    .               reduce using rule 5 (primitive -> BOOL .)
    ^               reduce using rule 5 (primitive -> BOOL .)
    (               reduce using rule 5 (primitive -> BOOL .)
    PLUSPLUS        reduce using rule 5 (primitive -> BOOL .)
    MINUSMINUS      reduce using rule 5 (primitive -> BOOL .)
    *               reduce using rule 5 (primitive -> BOOL .)
    /               reduce using rule 5 (primitive -> BOOL .)
    SLASHSLASH      reduce using rule 5 (primitive -> BOOL .)
    MOD             reduce using rule 5 (primitive -> BOOL .)
    +               reduce using rule 5 (primitive -> BOOL .)
    -               reduce using rule 5 (primitive -> BOOL .)
    LTLT            reduce using rule 5 (primitive -> BOOL .)
    GTGT            reduce using rule 5 (primitive -> BOOL .)
    <               reduce using rule 5 (primitive -> BOOL .)
    LE              reduce using rule 5 (primitive -> BOOL .)
    >               reduce using rule 5 (primitive -> BOOL .)
    GE              reduce using rule 5 (primitive -> BOOL .)
    NE              reduce using rule 5 (primitive -> BOOL .)
    EQ              reduce using rule 5 (primitive -> BOOL .)
    IS              reduce using rule 5 (primitive -> BOOL .)
    IN              reduce using rule 5 (primitive -> BOOL .)
    NOT             reduce using rule 5 (primitive -> BOOL .)
    |               reduce using rule 5 (primitive -> BOOL .)
    AND             reduce using rule 5 (primitive -> BOOL .)
    OR              reduce using rule 5 (primitive -> BOOL .)
    ,               reduce using rule 5 (primitive -> BOOL .)
    {               reduce using rule 5 (primitive -> BOOL .)
    NEWLINE         reduce using rule 5 (primitive -> BOOL .)
    $end            reduce using rule 5 (primitive -> BOOL .)
    )               reduce using rule 5 (primitive -> BOOL .)
    }               reduce using rule 5 (primitive -> BOOL .)
    ]               reduce using rule 5 (primitive -> BOOL .)
    AS              reduce using rule 5 (primitive -> BOOL .)
    :               reduce using rule 5 (primitive -> BOOL .)



state 46

    (93) statement -> block_s .

    NEWLINE         reduce using rule 93 (statement -> block_s .)
    $end            reduce using rule 93 (statement -> block_s .)
    }               reduce using rule 93 (statement -> block_s .)



state 47

    (59) test_un -> test_exp .

    PLUSPLUS        reduce using rule 59 (test_un -> test_exp .)
    MINUSMINUS      reduce using rule 59 (test_un -> test_exp .)
    *               reduce using rule 59 (test_un -> test_exp .)
    /               reduce using rule 59 (test_un -> test_exp .)
    SLASHSLASH      reduce using rule 59 (test_un -> test_exp .)
    MOD             reduce using rule 59 (test_un -> test_exp .)
    +               reduce using rule 59 (test_un -> test_exp .)
    -               reduce using rule 59 (test_un -> test_exp .)
    LTLT            reduce using rule 59 (test_un -> test_exp .)
    GTGT            reduce using rule 59 (test_un -> test_exp .)
    <               reduce using rule 59 (test_un -> test_exp .)
    LE              reduce using rule 59 (test_un -> test_exp .)
    >               reduce using rule 59 (test_un -> test_exp .)
    GE              reduce using rule 59 (test_un -> test_exp .)
    NE              reduce using rule 59 (test_un -> test_exp .)
    EQ              reduce using rule 59 (test_un -> test_exp .)
    IS              reduce using rule 59 (test_un -> test_exp .)
    IN              reduce using rule 59 (test_un -> test_exp .)
    NOT             reduce using rule 59 (test_un -> test_exp .)
    |               reduce using rule 59 (test_un -> test_exp .)
    AND             reduce using rule 59 (test_un -> test_exp .)
    OR              reduce using rule 59 (test_un -> test_exp .)
    NEWLINE         reduce using rule 59 (test_un -> test_exp .)
    $end            reduce using rule 59 (test_un -> test_exp .)
    )               reduce using rule 59 (test_un -> test_exp .)
    ,               reduce using rule 59 (test_un -> test_exp .)
    }               reduce using rule 59 (test_un -> test_exp .)
    ]               reduce using rule 59 (test_un -> test_exp .)
    {               reduce using rule 59 (test_un -> test_exp .)
    AS              reduce using rule 59 (test_un -> test_exp .)
    :               reduce using rule 59 (test_un -> test_exp .)



state 48

    (119) assert_s -> ASSERT . expression
    (120) assert_s -> ASSERT . expression , expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 117

state 49

    (122) block_s -> while_s .

    NEWLINE         reduce using rule 122 (block_s -> while_s .)
    $end            reduce using rule 122 (block_s -> while_s .)
    }               reduce using rule 122 (block_s -> while_s .)



state 50

    (57) test_un -> - . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_sub                       shift and go to state 52
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 118

state 51

    (76) test_sub -> test_basis .

    [               reduce using rule 76 (test_sub -> test_basis .)
    .               reduce using rule 76 (test_sub -> test_basis .)
    ^               reduce using rule 76 (test_sub -> test_basis .)
    (               reduce using rule 76 (test_sub -> test_basis .)
    PLUSPLUS        reduce using rule 76 (test_sub -> test_basis .)
    MINUSMINUS      reduce using rule 76 (test_sub -> test_basis .)
    *               reduce using rule 76 (test_sub -> test_basis .)
    /               reduce using rule 76 (test_sub -> test_basis .)
    SLASHSLASH      reduce using rule 76 (test_sub -> test_basis .)
    MOD             reduce using rule 76 (test_sub -> test_basis .)
    +               reduce using rule 76 (test_sub -> test_basis .)
    -               reduce using rule 76 (test_sub -> test_basis .)
    LTLT            reduce using rule 76 (test_sub -> test_basis .)
    GTGT            reduce using rule 76 (test_sub -> test_basis .)
    <               reduce using rule 76 (test_sub -> test_basis .)
    LE              reduce using rule 76 (test_sub -> test_basis .)
    >               reduce using rule 76 (test_sub -> test_basis .)
    GE              reduce using rule 76 (test_sub -> test_basis .)
    NE              reduce using rule 76 (test_sub -> test_basis .)
    EQ              reduce using rule 76 (test_sub -> test_basis .)
    IS              reduce using rule 76 (test_sub -> test_basis .)
    IN              reduce using rule 76 (test_sub -> test_basis .)
    NOT             reduce using rule 76 (test_sub -> test_basis .)
    |               reduce using rule 76 (test_sub -> test_basis .)
    AND             reduce using rule 76 (test_sub -> test_basis .)
    OR              reduce using rule 76 (test_sub -> test_basis .)
    NEWLINE         reduce using rule 76 (test_sub -> test_basis .)
    $end            reduce using rule 76 (test_sub -> test_basis .)
    )               reduce using rule 76 (test_sub -> test_basis .)
    ,               reduce using rule 76 (test_sub -> test_basis .)
    }               reduce using rule 76 (test_sub -> test_basis .)
    ]               reduce using rule 76 (test_sub -> test_basis .)
    {               reduce using rule 76 (test_sub -> test_basis .)
    AS              reduce using rule 76 (test_sub -> test_basis .)
    :               reduce using rule 76 (test_sub -> test_basis .)



state 52

    (73) test_attr -> test_sub .
    (74) test_sub -> test_sub . [ index ]
    (75) test_sub -> test_sub . [ index , ]

    .               reduce using rule 73 (test_attr -> test_sub .)
    ^               reduce using rule 73 (test_attr -> test_sub .)
    (               reduce using rule 73 (test_attr -> test_sub .)
    PLUSPLUS        reduce using rule 73 (test_attr -> test_sub .)
    MINUSMINUS      reduce using rule 73 (test_attr -> test_sub .)
    *               reduce using rule 73 (test_attr -> test_sub .)
    /               reduce using rule 73 (test_attr -> test_sub .)
    SLASHSLASH      reduce using rule 73 (test_attr -> test_sub .)
    MOD             reduce using rule 73 (test_attr -> test_sub .)
    +               reduce using rule 73 (test_attr -> test_sub .)
    -               reduce using rule 73 (test_attr -> test_sub .)
    LTLT            reduce using rule 73 (test_attr -> test_sub .)
    GTGT            reduce using rule 73 (test_attr -> test_sub .)
    <               reduce using rule 73 (test_attr -> test_sub .)
    LE              reduce using rule 73 (test_attr -> test_sub .)
    >               reduce using rule 73 (test_attr -> test_sub .)
    GE              reduce using rule 73 (test_attr -> test_sub .)
    NE              reduce using rule 73 (test_attr -> test_sub .)
    EQ              reduce using rule 73 (test_attr -> test_sub .)
    IS              reduce using rule 73 (test_attr -> test_sub .)
    IN              reduce using rule 73 (test_attr -> test_sub .)
    NOT             reduce using rule 73 (test_attr -> test_sub .)
    |               reduce using rule 73 (test_attr -> test_sub .)
    AND             reduce using rule 73 (test_attr -> test_sub .)
    OR              reduce using rule 73 (test_attr -> test_sub .)
    {               reduce using rule 73 (test_attr -> test_sub .)
    NEWLINE         reduce using rule 73 (test_attr -> test_sub .)
    $end            reduce using rule 73 (test_attr -> test_sub .)
    )               reduce using rule 73 (test_attr -> test_sub .)
    ,               reduce using rule 73 (test_attr -> test_sub .)
    }               reduce using rule 73 (test_attr -> test_sub .)
    ]               reduce using rule 73 (test_attr -> test_sub .)
    AS              reduce using rule 73 (test_attr -> test_sub .)
    :               reduce using rule 73 (test_attr -> test_sub .)
    [               shift and go to state 119



state 53

    (2) primitive -> STRING .

    [               reduce using rule 2 (primitive -> STRING .)
    .               reduce using rule 2 (primitive -> STRING .)
    ^               reduce using rule 2 (primitive -> STRING .)
    (               reduce using rule 2 (primitive -> STRING .)
    PLUSPLUS        reduce using rule 2 (primitive -> STRING .)
    MINUSMINUS      reduce using rule 2 (primitive -> STRING .)
    *               reduce using rule 2 (primitive -> STRING .)
    /               reduce using rule 2 (primitive -> STRING .)
    SLASHSLASH      reduce using rule 2 (primitive -> STRING .)
    MOD             reduce using rule 2 (primitive -> STRING .)
    +               reduce using rule 2 (primitive -> STRING .)
    -               reduce using rule 2 (primitive -> STRING .)
    LTLT            reduce using rule 2 (primitive -> STRING .)
    GTGT            reduce using rule 2 (primitive -> STRING .)
    <               reduce using rule 2 (primitive -> STRING .)
    LE              reduce using rule 2 (primitive -> STRING .)
    >               reduce using rule 2 (primitive -> STRING .)
    GE              reduce using rule 2 (primitive -> STRING .)
    NE              reduce using rule 2 (primitive -> STRING .)
    EQ              reduce using rule 2 (primitive -> STRING .)
    IS              reduce using rule 2 (primitive -> STRING .)
    IN              reduce using rule 2 (primitive -> STRING .)
    NOT             reduce using rule 2 (primitive -> STRING .)
    |               reduce using rule 2 (primitive -> STRING .)
    AND             reduce using rule 2 (primitive -> STRING .)
    OR              reduce using rule 2 (primitive -> STRING .)
    ,               reduce using rule 2 (primitive -> STRING .)
    {               reduce using rule 2 (primitive -> STRING .)
    NEWLINE         reduce using rule 2 (primitive -> STRING .)
    $end            reduce using rule 2 (primitive -> STRING .)
    )               reduce using rule 2 (primitive -> STRING .)
    }               reduce using rule 2 (primitive -> STRING .)
    ]               reduce using rule 2 (primitive -> STRING .)
    AS              reduce using rule 2 (primitive -> STRING .)
    :               reduce using rule 2 (primitive -> STRING .)



state 54

    (95) statement -> assignment .

    NEWLINE         reduce using rule 95 (statement -> assignment .)
    $end            reduce using rule 95 (statement -> assignment .)
    }               reduce using rule 95 (statement -> assignment .)



state 55

    (108) flow_s -> YIELD . comma_list
    (109) flow_s -> YIELD . comma_list ,
    (112) comma_list -> . comma_list , expression
    (113) comma_list -> . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    comma_list                     shift and go to state 120
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 72

state 56

    (13) literal -> { . list_items }
    (14) literal -> { . list_items , }
    (15) literal -> { . hash_items }
    (16) literal -> { . hash_items , }
    (17) literal -> { . }
    (18) list_items -> . list_items , expression
    (19) list_items -> . expression
    (20) hash_items -> . hash_items , primitive : expression
    (21) hash_items -> . hash_items , ident : expression
    (22) hash_items -> . primitive : expression
    (23) hash_items -> . ident : expression
    (88) expression -> . test_or
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (7) ident -> . IDENT
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }

    }               shift and go to state 123
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    IDENT           shift and go to state 15
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    [               shift and go to state 19
    {               shift and go to state 56


    primitive                      shift and go to state 82
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    hash_items                     shift and go to state 121
    test_comp                      shift and go to state 34
    list_items                     shift and go to state 122
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 86
    test_pm                        shift and go to state 60
    expression                     shift and go to state 87

state 57

    (126) if_if -> IF . expression block
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 124

state 58

    (64) test_call -> test_attr .
    (72) test_attr -> test_attr . . test_sub

    ^               reduce using rule 64 (test_call -> test_attr .)
    (               reduce using rule 64 (test_call -> test_attr .)
    PLUSPLUS        reduce using rule 64 (test_call -> test_attr .)
    MINUSMINUS      reduce using rule 64 (test_call -> test_attr .)
    *               reduce using rule 64 (test_call -> test_attr .)
    /               reduce using rule 64 (test_call -> test_attr .)
    SLASHSLASH      reduce using rule 64 (test_call -> test_attr .)
    MOD             reduce using rule 64 (test_call -> test_attr .)
    +               reduce using rule 64 (test_call -> test_attr .)
    -               reduce using rule 64 (test_call -> test_attr .)
    LTLT            reduce using rule 64 (test_call -> test_attr .)
    GTGT            reduce using rule 64 (test_call -> test_attr .)
    <               reduce using rule 64 (test_call -> test_attr .)
    LE              reduce using rule 64 (test_call -> test_attr .)
    >               reduce using rule 64 (test_call -> test_attr .)
    GE              reduce using rule 64 (test_call -> test_attr .)
    NE              reduce using rule 64 (test_call -> test_attr .)
    EQ              reduce using rule 64 (test_call -> test_attr .)
    IS              reduce using rule 64 (test_call -> test_attr .)
    IN              reduce using rule 64 (test_call -> test_attr .)
    NOT             reduce using rule 64 (test_call -> test_attr .)
    |               reduce using rule 64 (test_call -> test_attr .)
    AND             reduce using rule 64 (test_call -> test_attr .)
    OR              reduce using rule 64 (test_call -> test_attr .)
    ]               reduce using rule 64 (test_call -> test_attr .)
    ,               reduce using rule 64 (test_call -> test_attr .)
    )               reduce using rule 64 (test_call -> test_attr .)
    }               reduce using rule 64 (test_call -> test_attr .)
    NEWLINE         reduce using rule 64 (test_call -> test_attr .)
    $end            reduce using rule 64 (test_call -> test_attr .)
    {               reduce using rule 64 (test_call -> test_attr .)
    AS              reduce using rule 64 (test_call -> test_attr .)
    :               reduce using rule 64 (test_call -> test_attr .)
    .               shift and go to state 125



state 59

    (97) assignment -> many_idents . EQOP comma_list
    (101) many_idents -> many_idents . , ident

    EQOP            shift and go to state 126
    ,               shift and go to state 127



state 60

    (46) test_io -> test_pm .
    (47) test_pm -> test_pm . + test_mdmf
    (48) test_pm -> test_pm . - test_mdmf

    LTLT            reduce using rule 46 (test_io -> test_pm .)
    GTGT            reduce using rule 46 (test_io -> test_pm .)
    <               reduce using rule 46 (test_io -> test_pm .)
    LE              reduce using rule 46 (test_io -> test_pm .)
    >               reduce using rule 46 (test_io -> test_pm .)
    GE              reduce using rule 46 (test_io -> test_pm .)
    NE              reduce using rule 46 (test_io -> test_pm .)
    EQ              reduce using rule 46 (test_io -> test_pm .)
    IS              reduce using rule 46 (test_io -> test_pm .)
    IN              reduce using rule 46 (test_io -> test_pm .)
    NOT             reduce using rule 46 (test_io -> test_pm .)
    |               reduce using rule 46 (test_io -> test_pm .)
    AND             reduce using rule 46 (test_io -> test_pm .)
    OR              reduce using rule 46 (test_io -> test_pm .)
    NEWLINE         reduce using rule 46 (test_io -> test_pm .)
    $end            reduce using rule 46 (test_io -> test_pm .)
    }               reduce using rule 46 (test_io -> test_pm .)
    )               reduce using rule 46 (test_io -> test_pm .)
    ,               reduce using rule 46 (test_io -> test_pm .)
    ]               reduce using rule 46 (test_io -> test_pm .)
    {               reduce using rule 46 (test_io -> test_pm .)
    AS              reduce using rule 46 (test_io -> test_pm .)
    :               reduce using rule 46 (test_io -> test_pm .)
    +               shift and go to state 128
    -               shift and go to state 129



state 61

    (107) flow_s -> THROW . flow_item
    (110) flow_item -> . expression
    (111) flow_item -> .
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NEWLINE         reduce using rule 111 (flow_item -> .)
    $end            reduce using rule 111 (flow_item -> .)
    }               reduce using rule 111 (flow_item -> .)
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    flow_item                      shift and go to state 130
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 89

state 62

    (86) test_basis -> ident .

    [               reduce using rule 86 (test_basis -> ident .)
    .               reduce using rule 86 (test_basis -> ident .)
    ^               reduce using rule 86 (test_basis -> ident .)
    (               reduce using rule 86 (test_basis -> ident .)
    PLUSPLUS        reduce using rule 86 (test_basis -> ident .)
    MINUSMINUS      reduce using rule 86 (test_basis -> ident .)
    *               reduce using rule 86 (test_basis -> ident .)
    /               reduce using rule 86 (test_basis -> ident .)
    SLASHSLASH      reduce using rule 86 (test_basis -> ident .)
    MOD             reduce using rule 86 (test_basis -> ident .)
    +               reduce using rule 86 (test_basis -> ident .)
    -               reduce using rule 86 (test_basis -> ident .)
    LTLT            reduce using rule 86 (test_basis -> ident .)
    GTGT            reduce using rule 86 (test_basis -> ident .)
    <               reduce using rule 86 (test_basis -> ident .)
    LE              reduce using rule 86 (test_basis -> ident .)
    >               reduce using rule 86 (test_basis -> ident .)
    GE              reduce using rule 86 (test_basis -> ident .)
    NE              reduce using rule 86 (test_basis -> ident .)
    EQ              reduce using rule 86 (test_basis -> ident .)
    IS              reduce using rule 86 (test_basis -> ident .)
    IN              reduce using rule 86 (test_basis -> ident .)
    NOT             reduce using rule 86 (test_basis -> ident .)
    |               reduce using rule 86 (test_basis -> ident .)
    AND             reduce using rule 86 (test_basis -> ident .)
    OR              reduce using rule 86 (test_basis -> ident .)
    NEWLINE         reduce using rule 86 (test_basis -> ident .)
    $end            reduce using rule 86 (test_basis -> ident .)
    )               reduce using rule 86 (test_basis -> ident .)
    ,               reduce using rule 86 (test_basis -> ident .)
    }               reduce using rule 86 (test_basis -> ident .)
    ]               reduce using rule 86 (test_basis -> ident .)
    {               reduce using rule 86 (test_basis -> ident .)
    AS              reduce using rule 86 (test_basis -> ident .)
    :               reduce using rule 86 (test_basis -> ident .)



state 63

    (87) test_basis -> ( expression . )

    )               shift and go to state 131



state 64

    (127) if_elifs -> ELIF . expression block if_elifs
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    ident                          shift and go to state 62
    test_not                       shift and go to state 43
    test_attr                      shift and go to state 58
    test_pm                        shift and go to state 60
    expression                     shift and go to state 132

state 65

    (125) if_s -> if_if if_elifs . else
    (129) else -> . ELSE block
    (130) else -> .

    ELSE            shift and go to state 133
    NEWLINE         reduce using rule 130 (else -> .)
    $end            reduce using rule 130 (else -> .)
    }               reduce using rule 130 (else -> .)


    else                           shift and go to state 134

state 66

    (55) test_un -> test_un PLUSPLUS .

    PLUSPLUS        reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    MINUSMINUS      reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    *               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    /               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    SLASHSLASH      reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    MOD             reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    +               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    -               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    LTLT            reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    GTGT            reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    <               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    LE              reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    >               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    GE              reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    NE              reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    EQ              reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    IS              reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    IN              reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    NOT             reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    |               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    AND             reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    OR              reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    NEWLINE         reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    $end            reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    )               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    ,               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    }               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    ]               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    {               reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    AS              reduce using rule 55 (test_un -> test_un PLUSPLUS .)
    :               reduce using rule 55 (test_un -> test_un PLUSPLUS .)



state 67

    (56) test_un -> test_un MINUSMINUS .

    PLUSPLUS        reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    MINUSMINUS      reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    *               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    /               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    SLASHSLASH      reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    MOD             reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    +               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    -               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    LTLT            reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    GTGT            reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    <               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    LE              reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    >               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    GE              reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    NE              reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    EQ              reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    IS              reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    IN              reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    NOT             reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    |               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    AND             reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    OR              reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    NEWLINE         reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    $end            reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    )               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    ,               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    }               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    ]               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    {               reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    AS              reduce using rule 56 (test_un -> test_un MINUSMINUS .)
    :               reduce using rule 56 (test_un -> test_un MINUSMINUS .)



state 68

    (116) import_items -> ident . . import_items
    (117) import_items -> ident .

    .               shift and go to state 135
    AS              reduce using rule 117 (import_items -> ident .)
    NEWLINE         reduce using rule 117 (import_items -> ident .)
    $end            reduce using rule 117 (import_items -> ident .)
    }               reduce using rule 117 (import_items -> ident .)



state 69

    (114) import_s -> IMPORT import_items .
    (115) import_s -> IMPORT import_items . AS ident

    NEWLINE         reduce using rule 114 (import_s -> IMPORT import_items .)
    $end            reduce using rule 114 (import_s -> IMPORT import_items .)
    }               reduce using rule 114 (import_s -> IMPORT import_items .)
    AS              shift and go to state 136



state 70

    (118) import_items -> * .

    AS              reduce using rule 118 (import_items -> * .)
    NEWLINE         reduce using rule 118 (import_items -> * .)
    $end            reduce using rule 118 (import_items -> * .)
    }               reduce using rule 118 (import_items -> * .)



state 71

    (105) flow_s -> RETURN comma_list .
    (106) flow_s -> RETURN comma_list . ,
    (112) comma_list -> comma_list . , expression

    }               reduce using rule 105 (flow_s -> RETURN comma_list .)
    NEWLINE         reduce using rule 105 (flow_s -> RETURN comma_list .)
    $end            reduce using rule 105 (flow_s -> RETURN comma_list .)
    ,               shift and go to state 137



state 72

    (113) comma_list -> expression .

    ,               reduce using rule 113 (comma_list -> expression .)
    NEWLINE         reduce using rule 113 (comma_list -> expression .)
    $end            reduce using rule 113 (comma_list -> expression .)
    }               reduce using rule 113 (comma_list -> expression .)
    {               reduce using rule 113 (comma_list -> expression .)



state 73

    (99) var_s -> DEL many_idents .
    (101) many_idents -> many_idents . , ident

    }               reduce using rule 99 (var_s -> DEL many_idents .)
    NEWLINE         reduce using rule 99 (var_s -> DEL many_idents .)
    $end            reduce using rule 99 (var_s -> DEL many_idents .)
    ,               shift and go to state 127



state 74

    (102) many_idents -> ident .

    ,               reduce using rule 102 (many_idents -> ident .)
    NEWLINE         reduce using rule 102 (many_idents -> ident .)
    $end            reduce using rule 102 (many_idents -> ident .)
    }               reduce using rule 102 (many_idents -> ident .)
    EQOP            reduce using rule 102 (many_idents -> ident .)
    IN              reduce using rule 102 (many_idents -> ident .)



state 75

    (58) test_un -> + test_un .
    (55) test_un -> test_un . PLUSPLUS
    (56) test_un -> test_un . MINUSMINUS

    PLUSPLUS        reduce using rule 58 (test_un -> + test_un .)
    MINUSMINUS      reduce using rule 58 (test_un -> + test_un .)
    *               reduce using rule 58 (test_un -> + test_un .)
    /               reduce using rule 58 (test_un -> + test_un .)
    SLASHSLASH      reduce using rule 58 (test_un -> + test_un .)
    MOD             reduce using rule 58 (test_un -> + test_un .)
    +               reduce using rule 58 (test_un -> + test_un .)
    -               reduce using rule 58 (test_un -> + test_un .)
    LTLT            reduce using rule 58 (test_un -> + test_un .)
    GTGT            reduce using rule 58 (test_un -> + test_un .)
    <               reduce using rule 58 (test_un -> + test_un .)
    LE              reduce using rule 58 (test_un -> + test_un .)
    >               reduce using rule 58 (test_un -> + test_un .)
    GE              reduce using rule 58 (test_un -> + test_un .)
    NE              reduce using rule 58 (test_un -> + test_un .)
    EQ              reduce using rule 58 (test_un -> + test_un .)
    IS              reduce using rule 58 (test_un -> + test_un .)
    IN              reduce using rule 58 (test_un -> + test_un .)
    NOT             reduce using rule 58 (test_un -> + test_un .)
    |               reduce using rule 58 (test_un -> + test_un .)
    AND             reduce using rule 58 (test_un -> + test_un .)
    OR              reduce using rule 58 (test_un -> + test_un .)
    NEWLINE         reduce using rule 58 (test_un -> + test_un .)
    $end            reduce using rule 58 (test_un -> + test_un .)
    )               reduce using rule 58 (test_un -> + test_un .)
    ,               reduce using rule 58 (test_un -> + test_un .)
    }               reduce using rule 58 (test_un -> + test_un .)
    ]               reduce using rule 58 (test_un -> + test_un .)
    {               reduce using rule 58 (test_un -> + test_un .)
    AS              reduce using rule 58 (test_un -> + test_un .)
    :               reduce using rule 58 (test_un -> + test_un .)

  ! PLUSPLUS        [ shift and go to state 66 ]
  ! MINUSMINUS      [ shift and go to state 67 ]


state 76

    (24) test_or -> test_or OR . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 138
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60

state 77

    (134) for_s -> FOR many_idents . IN comma_list block else
    (101) many_idents -> many_idents . , ident

    IN              shift and go to state 139
    ,               shift and go to state 127



state 78

    (62) test_call -> test_call ( . arglist )
    (63) test_call -> test_call ( . arglist , )
    (65) arglist -> . arglist , arg
    (66) arglist -> . arg
    (67) arglist -> .
    (68) arg -> . expression
    (69) arg -> . ident = expression
    (70) arg -> . * ident
    (71) arg -> . * * ident
    (88) expression -> . test_or
    (7) ident -> . IDENT
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }

    )               reduce using rule 67 (arglist -> .)
    ,               reduce using rule 67 (arglist -> .)
    *               shift and go to state 142
    IDENT           shift and go to state 15
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    arg                            shift and go to state 140
    test_comp                      shift and go to state 34
    arglist                        shift and go to state 141
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 143
    test_pm                        shift and go to state 60
    expression                     shift and go to state 144

state 79

    (60) test_exp -> test_call ^ . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_sub                       shift and go to state 52
    test_exp                       shift and go to state 145
    test_basis                     shift and go to state 51
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58

state 80

    (131) block -> { . statements }
    (140) statements -> . statements NEWLINE
    (141) statements -> . statements NEWLINE statement
    (142) statements -> . statement
    (143) statements -> .
    (89) statement -> . expression
    (90) statement -> . var_s
    (91) statement -> . flow_s
    (92) statement -> . assert_s
    (93) statement -> . block_s
    (94) statement -> . import_s
    (95) statement -> . assignment
    (96) statement -> . declaration
    (88) expression -> . test_or
    (99) var_s -> . DEL many_idents
    (100) var_s -> . EXTERN many_idents
    (103) flow_s -> . BREAK flow_item
    (104) flow_s -> . CONTINUE flow_item
    (105) flow_s -> . RETURN comma_list
    (106) flow_s -> . RETURN comma_list ,
    (107) flow_s -> . THROW flow_item
    (108) flow_s -> . YIELD comma_list
    (109) flow_s -> . YIELD comma_list ,
    (119) assert_s -> . ASSERT expression
    (120) assert_s -> . ASSERT expression , expression
    (121) block_s -> . if_s
    (122) block_s -> . while_s
    (123) block_s -> . for_s
    (124) block_s -> . try_s
    (114) import_s -> . IMPORT import_items
    (115) import_s -> . IMPORT import_items AS ident
    (97) assignment -> . many_idents EQOP comma_list
    (98) declaration -> . ident assignment
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (125) if_s -> . if_if if_elifs else
    (132) while_s -> . WHILE expression block else
    (133) while_s -> . WHILE block else
    (134) for_s -> . FOR many_idents IN comma_list block else
    (135) try_s -> . try_try try_catch else
    (101) many_idents -> . many_idents , ident
    (102) many_idents -> . ident
    (7) ident -> . IDENT
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (126) if_if -> . IF expression block
    (136) try_try -> . TRY block
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }

    }               reduce using rule 143 (statements -> .)
    NEWLINE         reduce using rule 143 (statements -> .)
    DEL             shift and go to state 10
    EXTERN          shift and go to state 33
    BREAK           shift and go to state 44
    CONTINUE        shift and go to state 22
    RETURN          shift and go to state 9
    THROW           shift and go to state 61
    YIELD           shift and go to state 55
    ASSERT          shift and go to state 48
    IMPORT          shift and go to state 6
    WHILE           shift and go to state 32
    FOR             shift and go to state 16
    IDENT           shift and go to state 15
    IF              shift and go to state 57
    TRY             shift and go to state 18
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56


    flow_s                         shift and go to state 27
    primitive                      shift and go to state 28
    statements                     shift and go to state 146
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_exp                       shift and go to state 47
    while_s                        shift and go to state 49
    test_comp                      shift and go to state 34
    import_s                       shift and go to state 35
    try_s                          shift and go to state 1
    for_s                          shift and go to state 2
    test_type                      shift and go to state 36
    assert_s                       shift and go to state 12
    if_s                           shift and go to state 13
    if_if                          shift and go to state 4
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    statement                      shift and go to state 38
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    assignment                     shift and go to state 54
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    many_idents                    shift and go to state 59
    test_attr                      shift and go to state 58
    declaration                    shift and go to state 41
    test_not                       shift and go to state 43
    try_try                        shift and go to state 26
    ident                          shift and go to state 42
    test_in                        shift and go to state 40
    expression                     shift and go to state 25
    block_s                        shift and go to state 46
    test_pm                        shift and go to state 60
    var_s                          shift and go to state 8

state 81

    (136) try_try -> TRY block .

    CATCH           reduce using rule 136 (try_try -> TRY block .)
    ELSE            reduce using rule 136 (try_try -> TRY block .)
    }               reduce using rule 136 (try_try -> TRY block .)
    NEWLINE         reduce using rule 136 (try_try -> TRY block .)
    $end            reduce using rule 136 (try_try -> TRY block .)



state 82

    (22) hash_items -> primitive . : expression
    (84) test_basis -> primitive .

    :               shift and go to state 147
    [               reduce using rule 84 (test_basis -> primitive .)
    .               reduce using rule 84 (test_basis -> primitive .)
    ^               reduce using rule 84 (test_basis -> primitive .)
    (               reduce using rule 84 (test_basis -> primitive .)
    PLUSPLUS        reduce using rule 84 (test_basis -> primitive .)
    MINUSMINUS      reduce using rule 84 (test_basis -> primitive .)
    *               reduce using rule 84 (test_basis -> primitive .)
    /               reduce using rule 84 (test_basis -> primitive .)
    SLASHSLASH      reduce using rule 84 (test_basis -> primitive .)
    MOD             reduce using rule 84 (test_basis -> primitive .)
    +               reduce using rule 84 (test_basis -> primitive .)
    -               reduce using rule 84 (test_basis -> primitive .)
    LTLT            reduce using rule 84 (test_basis -> primitive .)
    GTGT            reduce using rule 84 (test_basis -> primitive .)
    <               reduce using rule 84 (test_basis -> primitive .)
    LE              reduce using rule 84 (test_basis -> primitive .)
    >               reduce using rule 84 (test_basis -> primitive .)
    GE              reduce using rule 84 (test_basis -> primitive .)
    NE              reduce using rule 84 (test_basis -> primitive .)
    EQ              reduce using rule 84 (test_basis -> primitive .)
    IS              reduce using rule 84 (test_basis -> primitive .)
    IN              reduce using rule 84 (test_basis -> primitive .)
    NOT             reduce using rule 84 (test_basis -> primitive .)
    |               reduce using rule 84 (test_basis -> primitive .)
    AND             reduce using rule 84 (test_basis -> primitive .)
    OR              reduce using rule 84 (test_basis -> primitive .)
    }               reduce using rule 84 (test_basis -> primitive .)
    ,               reduce using rule 84 (test_basis -> primitive .)
    NEWLINE         reduce using rule 84 (test_basis -> primitive .)
    ]               reduce using rule 84 (test_basis -> primitive .)



state 83

    (11) literal -> [ hash_items . ]
    (12) literal -> [ hash_items . , ]
    (20) hash_items -> hash_items . , primitive : expression
    (21) hash_items -> hash_items . , ident : expression

    ]               shift and go to state 149
    ,               shift and go to state 148



state 84

    (8) literal -> [ list_items . ]
    (9) literal -> [ list_items . , ]
    (18) list_items -> list_items . , expression

    ]               shift and go to state 150
    ,               shift and go to state 151



state 85

    (10) literal -> [ ] .

    [               reduce using rule 10 (literal -> [ ] .)
    .               reduce using rule 10 (literal -> [ ] .)
    ^               reduce using rule 10 (literal -> [ ] .)
    (               reduce using rule 10 (literal -> [ ] .)
    PLUSPLUS        reduce using rule 10 (literal -> [ ] .)
    MINUSMINUS      reduce using rule 10 (literal -> [ ] .)
    *               reduce using rule 10 (literal -> [ ] .)
    /               reduce using rule 10 (literal -> [ ] .)
    SLASHSLASH      reduce using rule 10 (literal -> [ ] .)
    MOD             reduce using rule 10 (literal -> [ ] .)
    +               reduce using rule 10 (literal -> [ ] .)
    -               reduce using rule 10 (literal -> [ ] .)
    LTLT            reduce using rule 10 (literal -> [ ] .)
    GTGT            reduce using rule 10 (literal -> [ ] .)
    <               reduce using rule 10 (literal -> [ ] .)
    LE              reduce using rule 10 (literal -> [ ] .)
    >               reduce using rule 10 (literal -> [ ] .)
    GE              reduce using rule 10 (literal -> [ ] .)
    NE              reduce using rule 10 (literal -> [ ] .)
    EQ              reduce using rule 10 (literal -> [ ] .)
    IS              reduce using rule 10 (literal -> [ ] .)
    IN              reduce using rule 10 (literal -> [ ] .)
    NOT             reduce using rule 10 (literal -> [ ] .)
    |               reduce using rule 10 (literal -> [ ] .)
    AND             reduce using rule 10 (literal -> [ ] .)
    OR              reduce using rule 10 (literal -> [ ] .)
    NEWLINE         reduce using rule 10 (literal -> [ ] .)
    $end            reduce using rule 10 (literal -> [ ] .)
    ]               reduce using rule 10 (literal -> [ ] .)
    ,               reduce using rule 10 (literal -> [ ] .)
    }               reduce using rule 10 (literal -> [ ] .)
    )               reduce using rule 10 (literal -> [ ] .)
    {               reduce using rule 10 (literal -> [ ] .)
    AS              reduce using rule 10 (literal -> [ ] .)
    :               reduce using rule 10 (literal -> [ ] .)



state 86

    (23) hash_items -> ident . : expression
    (86) test_basis -> ident .

    :               shift and go to state 152
    [               reduce using rule 86 (test_basis -> ident .)
    .               reduce using rule 86 (test_basis -> ident .)
    ^               reduce using rule 86 (test_basis -> ident .)
    (               reduce using rule 86 (test_basis -> ident .)
    PLUSPLUS        reduce using rule 86 (test_basis -> ident .)
    MINUSMINUS      reduce using rule 86 (test_basis -> ident .)
    *               reduce using rule 86 (test_basis -> ident .)
    /               reduce using rule 86 (test_basis -> ident .)
    SLASHSLASH      reduce using rule 86 (test_basis -> ident .)
    MOD             reduce using rule 86 (test_basis -> ident .)
    +               reduce using rule 86 (test_basis -> ident .)
    -               reduce using rule 86 (test_basis -> ident .)
    LTLT            reduce using rule 86 (test_basis -> ident .)
    GTGT            reduce using rule 86 (test_basis -> ident .)
    <               reduce using rule 86 (test_basis -> ident .)
    LE              reduce using rule 86 (test_basis -> ident .)
    >               reduce using rule 86 (test_basis -> ident .)
    GE              reduce using rule 86 (test_basis -> ident .)
    NE              reduce using rule 86 (test_basis -> ident .)
    EQ              reduce using rule 86 (test_basis -> ident .)
    IS              reduce using rule 86 (test_basis -> ident .)
    IN              reduce using rule 86 (test_basis -> ident .)
    NOT             reduce using rule 86 (test_basis -> ident .)
    |               reduce using rule 86 (test_basis -> ident .)
    AND             reduce using rule 86 (test_basis -> ident .)
    OR              reduce using rule 86 (test_basis -> ident .)
    }               reduce using rule 86 (test_basis -> ident .)
    ,               reduce using rule 86 (test_basis -> ident .)
    ]               reduce using rule 86 (test_basis -> ident .)



state 87

    (19) list_items -> expression .

    ]               reduce using rule 19 (list_items -> expression .)
    ,               reduce using rule 19 (list_items -> expression .)
    }               reduce using rule 19 (list_items -> expression .)



state 88

    (104) flow_s -> CONTINUE flow_item .

    }               reduce using rule 104 (flow_s -> CONTINUE flow_item .)
    NEWLINE         reduce using rule 104 (flow_s -> CONTINUE flow_item .)
    $end            reduce using rule 104 (flow_s -> CONTINUE flow_item .)



state 89

    (110) flow_item -> expression .

    NEWLINE         reduce using rule 110 (flow_item -> expression .)
    $end            reduce using rule 110 (flow_item -> expression .)
    }               reduce using rule 110 (flow_item -> expression .)



state 90

    (28) test_not -> NOT test_in .
    (30) test_in -> test_in . IN test_type
    (31) test_in -> test_in . NOT IN test_type
    (32) test_in -> test_in . | test_type

    AND             reduce using rule 28 (test_not -> NOT test_in .)
    OR              reduce using rule 28 (test_not -> NOT test_in .)
    :               reduce using rule 28 (test_not -> NOT test_in .)
    ]               reduce using rule 28 (test_not -> NOT test_in .)
    ,               reduce using rule 28 (test_not -> NOT test_in .)
    NEWLINE         reduce using rule 28 (test_not -> NOT test_in .)
    $end            reduce using rule 28 (test_not -> NOT test_in .)
    }               reduce using rule 28 (test_not -> NOT test_in .)
    )               reduce using rule 28 (test_not -> NOT test_in .)
    {               reduce using rule 28 (test_not -> NOT test_in .)
    AS              reduce using rule 28 (test_not -> NOT test_in .)
    IN              shift and go to state 114
    NOT             shift and go to state 112
    |               shift and go to state 113



state 91

    (135) try_s -> try_try try_catch . else
    (129) else -> . ELSE block
    (130) else -> .

    ELSE            shift and go to state 133
    NEWLINE         reduce using rule 130 (else -> .)
    $end            reduce using rule 130 (else -> .)
    }               reduce using rule 130 (else -> .)


    else                           shift and go to state 153

state 92

    (137) try_catch -> CATCH . expression block try_catch
    (138) try_catch -> CATCH . expression AS ident block try_catch
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 154

state 93

    (140) statements -> statements NEWLINE .
    (141) statements -> statements NEWLINE . statement
    (89) statement -> . expression
    (90) statement -> . var_s
    (91) statement -> . flow_s
    (92) statement -> . assert_s
    (93) statement -> . block_s
    (94) statement -> . import_s
    (95) statement -> . assignment
    (96) statement -> . declaration
    (88) expression -> . test_or
    (99) var_s -> . DEL many_idents
    (100) var_s -> . EXTERN many_idents
    (103) flow_s -> . BREAK flow_item
    (104) flow_s -> . CONTINUE flow_item
    (105) flow_s -> . RETURN comma_list
    (106) flow_s -> . RETURN comma_list ,
    (107) flow_s -> . THROW flow_item
    (108) flow_s -> . YIELD comma_list
    (109) flow_s -> . YIELD comma_list ,
    (119) assert_s -> . ASSERT expression
    (120) assert_s -> . ASSERT expression , expression
    (121) block_s -> . if_s
    (122) block_s -> . while_s
    (123) block_s -> . for_s
    (124) block_s -> . try_s
    (114) import_s -> . IMPORT import_items
    (115) import_s -> . IMPORT import_items AS ident
    (97) assignment -> . many_idents EQOP comma_list
    (98) declaration -> . ident assignment
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (125) if_s -> . if_if if_elifs else
    (132) while_s -> . WHILE expression block else
    (133) while_s -> . WHILE block else
    (134) for_s -> . FOR many_idents IN comma_list block else
    (135) try_s -> . try_try try_catch else
    (101) many_idents -> . many_idents , ident
    (102) many_idents -> . ident
    (7) ident -> . IDENT
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (126) if_if -> . IF expression block
    (136) try_try -> . TRY block
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }

    }               reduce using rule 140 (statements -> statements NEWLINE .)
    NEWLINE         reduce using rule 140 (statements -> statements NEWLINE .)
    $end            reduce using rule 140 (statements -> statements NEWLINE .)
    DEL             shift and go to state 10
    EXTERN          shift and go to state 33
    BREAK           shift and go to state 44
    CONTINUE        shift and go to state 22
    RETURN          shift and go to state 9
    THROW           shift and go to state 61
    YIELD           shift and go to state 55
    ASSERT          shift and go to state 48
    IMPORT          shift and go to state 6
    WHILE           shift and go to state 32
    FOR             shift and go to state 16
    IDENT           shift and go to state 15
    IF              shift and go to state 57
    TRY             shift and go to state 18
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56


    flow_s                         shift and go to state 27
    primitive                      shift and go to state 28
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_exp                       shift and go to state 47
    while_s                        shift and go to state 49
    test_comp                      shift and go to state 34
    import_s                       shift and go to state 35
    try_s                          shift and go to state 1
    for_s                          shift and go to state 2
    test_type                      shift and go to state 36
    assert_s                       shift and go to state 12
    if_s                           shift and go to state 13
    if_if                          shift and go to state 4
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    statement                      shift and go to state 155
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    assignment                     shift and go to state 54
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    many_idents                    shift and go to state 59
    test_attr                      shift and go to state 58
    declaration                    shift and go to state 41
    test_not                       shift and go to state 43
    try_try                        shift and go to state 26
    ident                          shift and go to state 42
    test_in                        shift and go to state 40
    expression                     shift and go to state 25
    block_s                        shift and go to state 46
    test_pm                        shift and go to state 60
    var_s                          shift and go to state 8

state 94

    (26) test_and -> test_and AND . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 156
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60

state 95

    (52) test_mdmf -> test_mdmf SLASHSLASH . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_attr                      shift and go to state 58
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    literal                        shift and go to state 37
    test_sub                       shift and go to state 52
    test_un                        shift and go to state 157

state 96

    (50) test_mdmf -> test_mdmf * . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_attr                      shift and go to state 58
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    literal                        shift and go to state 37
    test_sub                       shift and go to state 52
    test_un                        shift and go to state 158

state 97

    (51) test_mdmf -> test_mdmf / . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_attr                      shift and go to state 58
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    literal                        shift and go to state 37
    test_sub                       shift and go to state 52
    test_un                        shift and go to state 159

state 98

    (53) test_mdmf -> test_mdmf MOD . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_attr                      shift and go to state 58
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    literal                        shift and go to state 37
    test_sub                       shift and go to state 52
    test_un                        shift and go to state 160

state 99

    (132) while_s -> WHILE expression . block else
    (131) block -> . { statements }

    {               shift and go to state 80


    block                          shift and go to state 161

state 100

    (131) block -> { . statements }
    (13) literal -> { . list_items }
    (14) literal -> { . list_items , }
    (15) literal -> { . hash_items }
    (16) literal -> { . hash_items , }
    (17) literal -> { . }
    (140) statements -> . statements NEWLINE
    (141) statements -> . statements NEWLINE statement
    (142) statements -> . statement
    (143) statements -> .
    (18) list_items -> . list_items , expression
    (19) list_items -> . expression
    (20) hash_items -> . hash_items , primitive : expression
    (21) hash_items -> . hash_items , ident : expression
    (22) hash_items -> . primitive : expression
    (23) hash_items -> . ident : expression
    (89) statement -> . expression
    (90) statement -> . var_s
    (91) statement -> . flow_s
    (92) statement -> . assert_s
    (93) statement -> . block_s
    (94) statement -> . import_s
    (95) statement -> . assignment
    (96) statement -> . declaration
    (88) expression -> . test_or
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (7) ident -> . IDENT
    (99) var_s -> . DEL many_idents
    (100) var_s -> . EXTERN many_idents
    (103) flow_s -> . BREAK flow_item
    (104) flow_s -> . CONTINUE flow_item
    (105) flow_s -> . RETURN comma_list
    (106) flow_s -> . RETURN comma_list ,
    (107) flow_s -> . THROW flow_item
    (108) flow_s -> . YIELD comma_list
    (109) flow_s -> . YIELD comma_list ,
    (119) assert_s -> . ASSERT expression
    (120) assert_s -> . ASSERT expression , expression
    (121) block_s -> . if_s
    (122) block_s -> . while_s
    (123) block_s -> . for_s
    (124) block_s -> . try_s
    (114) import_s -> . IMPORT import_items
    (115) import_s -> . IMPORT import_items AS ident
    (97) assignment -> . many_idents EQOP comma_list
    (98) declaration -> . ident assignment
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (125) if_s -> . if_if if_elifs else
    (132) while_s -> . WHILE expression block else
    (133) while_s -> . WHILE block else
    (134) for_s -> . FOR many_idents IN comma_list block else
    (135) try_s -> . try_try try_catch else
    (101) many_idents -> . many_idents , ident
    (102) many_idents -> . ident
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (126) if_if -> . IF expression block
    (136) try_try -> . TRY block
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }

  ! shift/reduce conflict for } resolved as shift.
    }               shift and go to state 123
    NEWLINE         reduce using rule 143 (statements -> .)
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    IDENT           shift and go to state 15
    DEL             shift and go to state 10
    EXTERN          shift and go to state 33
    BREAK           shift and go to state 44
    CONTINUE        shift and go to state 22
    RETURN          shift and go to state 9
    THROW           shift and go to state 61
    YIELD           shift and go to state 55
    ASSERT          shift and go to state 48
    IMPORT          shift and go to state 6
    WHILE           shift and go to state 32
    FOR             shift and go to state 16
    IF              shift and go to state 57
    TRY             shift and go to state 18
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    [               shift and go to state 19
    {               shift and go to state 56

  ! }               [ reduce using rule 143 (statements -> .) ]

    flow_s                         shift and go to state 27
    primitive                      shift and go to state 82
    statements                     shift and go to state 146
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    hash_items                     shift and go to state 121
    test_exp                       shift and go to state 47
    while_s                        shift and go to state 49
    test_comp                      shift and go to state 34
    import_s                       shift and go to state 35
    list_items                     shift and go to state 122
    try_s                          shift and go to state 1
    for_s                          shift and go to state 2
    test_type                      shift and go to state 36
    assert_s                       shift and go to state 12
    if_s                           shift and go to state 13
    if_if                          shift and go to state 4
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    statement                      shift and go to state 38
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    assignment                     shift and go to state 54
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    many_idents                    shift and go to state 59
    test_attr                      shift and go to state 58
    declaration                    shift and go to state 41
    test_not                       shift and go to state 43
    try_try                        shift and go to state 26
    ident                          shift and go to state 163
    test_in                        shift and go to state 40
    expression                     shift and go to state 162
    block_s                        shift and go to state 46
    test_pm                        shift and go to state 60
    var_s                          shift and go to state 8

state 101

    (133) while_s -> WHILE block . else
    (129) else -> . ELSE block
    (130) else -> .

    ELSE            shift and go to state 133
    NEWLINE         reduce using rule 130 (else -> .)
    $end            reduce using rule 130 (else -> .)
    }               reduce using rule 130 (else -> .)


    else                           shift and go to state 164

state 102

    (100) var_s -> EXTERN many_idents .
    (101) many_idents -> many_idents . , ident

    }               reduce using rule 100 (var_s -> EXTERN many_idents .)
    NEWLINE         reduce using rule 100 (var_s -> EXTERN many_idents .)
    $end            reduce using rule 100 (var_s -> EXTERN many_idents .)
    ,               shift and go to state 127



state 103

    (38) test_comp -> test_comp LE . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 165
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_sub                       shift and go to state 52

state 104

    (41) test_comp -> test_comp NE . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 166
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_sub                       shift and go to state 52

state 105

    (40) test_comp -> test_comp GE . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 167
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_sub                       shift and go to state 52

state 106

    (42) test_comp -> test_comp EQ . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 168
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_sub                       shift and go to state 52

state 107

    (37) test_comp -> test_comp < . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 169
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_sub                       shift and go to state 52

state 108

    (39) test_comp -> test_comp > . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 170
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_sub                       shift and go to state 52

state 109

    (34) test_type -> test_type IS . test_comp
    (35) test_type -> test_type IS . NOT test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 172
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_comp                      shift and go to state 171
    test_sub                       shift and go to state 52

state 110

    (45) test_io -> test_io GTGT . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_attr                      shift and go to state 58
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    literal                        shift and go to state 37
    test_sub                       shift and go to state 52
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 173

state 111

    (44) test_io -> test_io LTLT . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_attr                      shift and go to state 58
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    literal                        shift and go to state 37
    test_sub                       shift and go to state 52
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 174

state 112

    (31) test_in -> test_in NOT . IN test_type

    IN              shift and go to state 175



state 113

    (32) test_in -> test_in | . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    test_type                      shift and go to state 176
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_comp                      shift and go to state 34
    test_sub                       shift and go to state 52

state 114

    (30) test_in -> test_in IN . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    test_type                      shift and go to state 177
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_comp                      shift and go to state 34
    test_sub                       shift and go to state 52

state 115

    (98) declaration -> ident assignment .

    }               reduce using rule 98 (declaration -> ident assignment .)
    NEWLINE         reduce using rule 98 (declaration -> ident assignment .)
    $end            reduce using rule 98 (declaration -> ident assignment .)



state 116

    (103) flow_s -> BREAK flow_item .

    }               reduce using rule 103 (flow_s -> BREAK flow_item .)
    NEWLINE         reduce using rule 103 (flow_s -> BREAK flow_item .)
    $end            reduce using rule 103 (flow_s -> BREAK flow_item .)



state 117

    (119) assert_s -> ASSERT expression .
    (120) assert_s -> ASSERT expression . , expression

    NEWLINE         reduce using rule 119 (assert_s -> ASSERT expression .)
    $end            reduce using rule 119 (assert_s -> ASSERT expression .)
    }               reduce using rule 119 (assert_s -> ASSERT expression .)
    ,               shift and go to state 178



state 118

    (57) test_un -> - test_un .
    (55) test_un -> test_un . PLUSPLUS
    (56) test_un -> test_un . MINUSMINUS

    PLUSPLUS        reduce using rule 57 (test_un -> - test_un .)
    MINUSMINUS      reduce using rule 57 (test_un -> - test_un .)
    *               reduce using rule 57 (test_un -> - test_un .)
    /               reduce using rule 57 (test_un -> - test_un .)
    SLASHSLASH      reduce using rule 57 (test_un -> - test_un .)
    MOD             reduce using rule 57 (test_un -> - test_un .)
    +               reduce using rule 57 (test_un -> - test_un .)
    -               reduce using rule 57 (test_un -> - test_un .)
    LTLT            reduce using rule 57 (test_un -> - test_un .)
    GTGT            reduce using rule 57 (test_un -> - test_un .)
    <               reduce using rule 57 (test_un -> - test_un .)
    LE              reduce using rule 57 (test_un -> - test_un .)
    >               reduce using rule 57 (test_un -> - test_un .)
    GE              reduce using rule 57 (test_un -> - test_un .)
    NE              reduce using rule 57 (test_un -> - test_un .)
    EQ              reduce using rule 57 (test_un -> - test_un .)
    IS              reduce using rule 57 (test_un -> - test_un .)
    IN              reduce using rule 57 (test_un -> - test_un .)
    NOT             reduce using rule 57 (test_un -> - test_un .)
    |               reduce using rule 57 (test_un -> - test_un .)
    AND             reduce using rule 57 (test_un -> - test_un .)
    OR              reduce using rule 57 (test_un -> - test_un .)
    NEWLINE         reduce using rule 57 (test_un -> - test_un .)
    $end            reduce using rule 57 (test_un -> - test_un .)
    )               reduce using rule 57 (test_un -> - test_un .)
    ,               reduce using rule 57 (test_un -> - test_un .)
    }               reduce using rule 57 (test_un -> - test_un .)
    ]               reduce using rule 57 (test_un -> - test_un .)
    {               reduce using rule 57 (test_un -> - test_un .)
    AS              reduce using rule 57 (test_un -> - test_un .)
    :               reduce using rule 57 (test_un -> - test_un .)

  ! PLUSPLUS        [ shift and go to state 66 ]
  ! MINUSMINUS      [ shift and go to state 67 ]


state 119

    (74) test_sub -> test_sub [ . index ]
    (75) test_sub -> test_sub [ . index , ]
    (77) index -> . index , indice
    (78) index -> . indice
    (79) indice -> . expression : expression : expression
    (80) indice -> . expression : expression
    (81) indice -> . expression
    (82) indice -> . DOTDOTDOT
    (83) indice -> .
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    DOTDOTDOT       shift and go to state 181
    ]               reduce using rule 83 (indice -> .)
    ,               reduce using rule 83 (indice -> .)
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    indice                         shift and go to state 179
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    primitive                      shift and go to state 28
    index                          shift and go to state 180
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 182

state 120

    (108) flow_s -> YIELD comma_list .
    (109) flow_s -> YIELD comma_list . ,
    (112) comma_list -> comma_list . , expression

    }               reduce using rule 108 (flow_s -> YIELD comma_list .)
    NEWLINE         reduce using rule 108 (flow_s -> YIELD comma_list .)
    $end            reduce using rule 108 (flow_s -> YIELD comma_list .)
    ,               shift and go to state 183



state 121

    (15) literal -> { hash_items . }
    (16) literal -> { hash_items . , }
    (20) hash_items -> hash_items . , primitive : expression
    (21) hash_items -> hash_items . , ident : expression

    }               shift and go to state 185
    ,               shift and go to state 184



state 122

    (13) literal -> { list_items . }
    (14) literal -> { list_items . , }
    (18) list_items -> list_items . , expression

    }               shift and go to state 186
    ,               shift and go to state 187



state 123

    (17) literal -> { } .

    [               reduce using rule 17 (literal -> { } .)
    .               reduce using rule 17 (literal -> { } .)
    ^               reduce using rule 17 (literal -> { } .)
    (               reduce using rule 17 (literal -> { } .)
    PLUSPLUS        reduce using rule 17 (literal -> { } .)
    MINUSMINUS      reduce using rule 17 (literal -> { } .)
    *               reduce using rule 17 (literal -> { } .)
    /               reduce using rule 17 (literal -> { } .)
    SLASHSLASH      reduce using rule 17 (literal -> { } .)
    MOD             reduce using rule 17 (literal -> { } .)
    +               reduce using rule 17 (literal -> { } .)
    -               reduce using rule 17 (literal -> { } .)
    LTLT            reduce using rule 17 (literal -> { } .)
    GTGT            reduce using rule 17 (literal -> { } .)
    <               reduce using rule 17 (literal -> { } .)
    LE              reduce using rule 17 (literal -> { } .)
    >               reduce using rule 17 (literal -> { } .)
    GE              reduce using rule 17 (literal -> { } .)
    NE              reduce using rule 17 (literal -> { } .)
    EQ              reduce using rule 17 (literal -> { } .)
    IS              reduce using rule 17 (literal -> { } .)
    IN              reduce using rule 17 (literal -> { } .)
    NOT             reduce using rule 17 (literal -> { } .)
    |               reduce using rule 17 (literal -> { } .)
    AND             reduce using rule 17 (literal -> { } .)
    OR              reduce using rule 17 (literal -> { } .)
    NEWLINE         reduce using rule 17 (literal -> { } .)
    $end            reduce using rule 17 (literal -> { } .)
    ]               reduce using rule 17 (literal -> { } .)
    ,               reduce using rule 17 (literal -> { } .)
    }               reduce using rule 17 (literal -> { } .)
    )               reduce using rule 17 (literal -> { } .)
    {               reduce using rule 17 (literal -> { } .)
    AS              reduce using rule 17 (literal -> { } .)
    :               reduce using rule 17 (literal -> { } .)



state 124

    (126) if_if -> IF expression . block
    (131) block -> . { statements }

    {               shift and go to state 80


    block                          shift and go to state 188

state 125

    (72) test_attr -> test_attr . . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_basis                     shift and go to state 51
    ident                          shift and go to state 62
    literal                        shift and go to state 37
    test_sub                       shift and go to state 189

state 126

    (97) assignment -> many_idents EQOP . comma_list
    (112) comma_list -> . comma_list , expression
    (113) comma_list -> . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    comma_list                     shift and go to state 190
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    ident                          shift and go to state 62
    test_not                       shift and go to state 43
    test_attr                      shift and go to state 58
    test_pm                        shift and go to state 60
    expression                     shift and go to state 72

state 127

    (101) many_idents -> many_idents , . ident
    (7) ident -> . IDENT

    IDENT           shift and go to state 15


    ident                          shift and go to state 191

state 128

    (47) test_pm -> test_pm + . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_attr                      shift and go to state 58
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 192
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    literal                        shift and go to state 37
    test_sub                       shift and go to state 52
    test_un                        shift and go to state 5

state 129

    (48) test_pm -> test_pm - . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_attr                      shift and go to state 58
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 193
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    literal                        shift and go to state 37
    test_sub                       shift and go to state 52
    test_un                        shift and go to state 5

state 130

    (107) flow_s -> THROW flow_item .

    }               reduce using rule 107 (flow_s -> THROW flow_item .)
    NEWLINE         reduce using rule 107 (flow_s -> THROW flow_item .)
    $end            reduce using rule 107 (flow_s -> THROW flow_item .)



state 131

    (87) test_basis -> ( expression ) .

    [               reduce using rule 87 (test_basis -> ( expression ) .)
    .               reduce using rule 87 (test_basis -> ( expression ) .)
    ^               reduce using rule 87 (test_basis -> ( expression ) .)
    (               reduce using rule 87 (test_basis -> ( expression ) .)
    PLUSPLUS        reduce using rule 87 (test_basis -> ( expression ) .)
    MINUSMINUS      reduce using rule 87 (test_basis -> ( expression ) .)
    *               reduce using rule 87 (test_basis -> ( expression ) .)
    /               reduce using rule 87 (test_basis -> ( expression ) .)
    SLASHSLASH      reduce using rule 87 (test_basis -> ( expression ) .)
    MOD             reduce using rule 87 (test_basis -> ( expression ) .)
    +               reduce using rule 87 (test_basis -> ( expression ) .)
    -               reduce using rule 87 (test_basis -> ( expression ) .)
    LTLT            reduce using rule 87 (test_basis -> ( expression ) .)
    GTGT            reduce using rule 87 (test_basis -> ( expression ) .)
    <               reduce using rule 87 (test_basis -> ( expression ) .)
    LE              reduce using rule 87 (test_basis -> ( expression ) .)
    >               reduce using rule 87 (test_basis -> ( expression ) .)
    GE              reduce using rule 87 (test_basis -> ( expression ) .)
    NE              reduce using rule 87 (test_basis -> ( expression ) .)
    EQ              reduce using rule 87 (test_basis -> ( expression ) .)
    IS              reduce using rule 87 (test_basis -> ( expression ) .)
    IN              reduce using rule 87 (test_basis -> ( expression ) .)
    NOT             reduce using rule 87 (test_basis -> ( expression ) .)
    |               reduce using rule 87 (test_basis -> ( expression ) .)
    AND             reduce using rule 87 (test_basis -> ( expression ) .)
    OR              reduce using rule 87 (test_basis -> ( expression ) .)
    NEWLINE         reduce using rule 87 (test_basis -> ( expression ) .)
    $end            reduce using rule 87 (test_basis -> ( expression ) .)
    )               reduce using rule 87 (test_basis -> ( expression ) .)
    ,               reduce using rule 87 (test_basis -> ( expression ) .)
    }               reduce using rule 87 (test_basis -> ( expression ) .)
    ]               reduce using rule 87 (test_basis -> ( expression ) .)
    {               reduce using rule 87 (test_basis -> ( expression ) .)
    AS              reduce using rule 87 (test_basis -> ( expression ) .)
    :               reduce using rule 87 (test_basis -> ( expression ) .)



state 132

    (127) if_elifs -> ELIF expression . block if_elifs
    (131) block -> . { statements }

    {               shift and go to state 80


    block                          shift and go to state 194

state 133

    (129) else -> ELSE . block
    (131) block -> . { statements }

    {               shift and go to state 80


    block                          shift and go to state 195

state 134

    (125) if_s -> if_if if_elifs else .

    NEWLINE         reduce using rule 125 (if_s -> if_if if_elifs else .)
    $end            reduce using rule 125 (if_s -> if_if if_elifs else .)
    }               reduce using rule 125 (if_s -> if_if if_elifs else .)



state 135

    (116) import_items -> ident . . import_items
    (116) import_items -> . ident . import_items
    (117) import_items -> . ident
    (118) import_items -> . *
    (7) ident -> . IDENT

    *               shift and go to state 70
    IDENT           shift and go to state 15


    import_items                   shift and go to state 196
    ident                          shift and go to state 68

state 136

    (115) import_s -> IMPORT import_items AS . ident
    (7) ident -> . IDENT

    IDENT           shift and go to state 15


    ident                          shift and go to state 197

state 137

    (106) flow_s -> RETURN comma_list , .
    (112) comma_list -> comma_list , . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    }               reduce using rule 106 (flow_s -> RETURN comma_list , .)
    NEWLINE         reduce using rule 106 (flow_s -> RETURN comma_list , .)
    $end            reduce using rule 106 (flow_s -> RETURN comma_list , .)
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 198

state 138

    (24) test_or -> test_or OR test_and .
    (26) test_and -> test_and . AND test_not

    OR              reduce using rule 24 (test_or -> test_or OR test_and .)
    ]               reduce using rule 24 (test_or -> test_or OR test_and .)
    ,               reduce using rule 24 (test_or -> test_or OR test_and .)
    }               reduce using rule 24 (test_or -> test_or OR test_and .)
    NEWLINE         reduce using rule 24 (test_or -> test_or OR test_and .)
    $end            reduce using rule 24 (test_or -> test_or OR test_and .)
    )               reduce using rule 24 (test_or -> test_or OR test_and .)
    :               reduce using rule 24 (test_or -> test_or OR test_and .)
    {               reduce using rule 24 (test_or -> test_or OR test_and .)
    AS              reduce using rule 24 (test_or -> test_or OR test_and .)
    AND             shift and go to state 94



state 139

    (134) for_s -> FOR many_idents IN . comma_list block else
    (112) comma_list -> . comma_list , expression
    (113) comma_list -> . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    comma_list                     shift and go to state 199
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    ident                          shift and go to state 62
    test_not                       shift and go to state 43
    test_attr                      shift and go to state 58
    test_pm                        shift and go to state 60
    expression                     shift and go to state 72

state 140

    (66) arglist -> arg .

    )               reduce using rule 66 (arglist -> arg .)
    ,               reduce using rule 66 (arglist -> arg .)



state 141

    (62) test_call -> test_call ( arglist . )
    (63) test_call -> test_call ( arglist . , )
    (65) arglist -> arglist . , arg

    )               shift and go to state 200
    ,               shift and go to state 201



state 142

    (70) arg -> * . ident
    (71) arg -> * . * ident
    (7) ident -> . IDENT

    *               shift and go to state 203
    IDENT           shift and go to state 15


    ident                          shift and go to state 202

state 143

    (69) arg -> ident . = expression
    (86) test_basis -> ident .

    =               shift and go to state 204
    [               reduce using rule 86 (test_basis -> ident .)
    .               reduce using rule 86 (test_basis -> ident .)
    ^               reduce using rule 86 (test_basis -> ident .)
    (               reduce using rule 86 (test_basis -> ident .)
    PLUSPLUS        reduce using rule 86 (test_basis -> ident .)
    MINUSMINUS      reduce using rule 86 (test_basis -> ident .)
    *               reduce using rule 86 (test_basis -> ident .)
    /               reduce using rule 86 (test_basis -> ident .)
    SLASHSLASH      reduce using rule 86 (test_basis -> ident .)
    MOD             reduce using rule 86 (test_basis -> ident .)
    +               reduce using rule 86 (test_basis -> ident .)
    -               reduce using rule 86 (test_basis -> ident .)
    LTLT            reduce using rule 86 (test_basis -> ident .)
    GTGT            reduce using rule 86 (test_basis -> ident .)
    <               reduce using rule 86 (test_basis -> ident .)
    LE              reduce using rule 86 (test_basis -> ident .)
    >               reduce using rule 86 (test_basis -> ident .)
    GE              reduce using rule 86 (test_basis -> ident .)
    NE              reduce using rule 86 (test_basis -> ident .)
    EQ              reduce using rule 86 (test_basis -> ident .)
    IS              reduce using rule 86 (test_basis -> ident .)
    IN              reduce using rule 86 (test_basis -> ident .)
    NOT             reduce using rule 86 (test_basis -> ident .)
    |               reduce using rule 86 (test_basis -> ident .)
    AND             reduce using rule 86 (test_basis -> ident .)
    OR              reduce using rule 86 (test_basis -> ident .)
    )               reduce using rule 86 (test_basis -> ident .)
    ,               reduce using rule 86 (test_basis -> ident .)



state 144

    (68) arg -> expression .

    )               reduce using rule 68 (arg -> expression .)
    ,               reduce using rule 68 (arg -> expression .)



state 145

    (60) test_exp -> test_call ^ test_exp .

    PLUSPLUS        reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    MINUSMINUS      reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    *               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    /               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    SLASHSLASH      reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    MOD             reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    +               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    -               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    LTLT            reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    GTGT            reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    <               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    LE              reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    >               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    GE              reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    NE              reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    EQ              reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    IS              reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    IN              reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    NOT             reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    |               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    AND             reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    OR              reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    NEWLINE         reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    $end            reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    )               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    ,               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    }               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    ]               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    {               reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    AS              reduce using rule 60 (test_exp -> test_call ^ test_exp .)
    :               reduce using rule 60 (test_exp -> test_call ^ test_exp .)



state 146

    (131) block -> { statements . }
    (140) statements -> statements . NEWLINE
    (141) statements -> statements . NEWLINE statement

    }               shift and go to state 205
    NEWLINE         shift and go to state 93



state 147

    (22) hash_items -> primitive : . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 206

state 148

    (12) literal -> [ hash_items , . ]
    (20) hash_items -> hash_items , . primitive : expression
    (21) hash_items -> hash_items , . ident : expression
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (7) ident -> . IDENT

    ]               shift and go to state 209
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    IDENT           shift and go to state 15


    primitive                      shift and go to state 207
    ident                          shift and go to state 208

state 149

    (11) literal -> [ hash_items ] .

    [               reduce using rule 11 (literal -> [ hash_items ] .)
    .               reduce using rule 11 (literal -> [ hash_items ] .)
    ^               reduce using rule 11 (literal -> [ hash_items ] .)
    (               reduce using rule 11 (literal -> [ hash_items ] .)
    PLUSPLUS        reduce using rule 11 (literal -> [ hash_items ] .)
    MINUSMINUS      reduce using rule 11 (literal -> [ hash_items ] .)
    *               reduce using rule 11 (literal -> [ hash_items ] .)
    /               reduce using rule 11 (literal -> [ hash_items ] .)
    SLASHSLASH      reduce using rule 11 (literal -> [ hash_items ] .)
    MOD             reduce using rule 11 (literal -> [ hash_items ] .)
    +               reduce using rule 11 (literal -> [ hash_items ] .)
    -               reduce using rule 11 (literal -> [ hash_items ] .)
    LTLT            reduce using rule 11 (literal -> [ hash_items ] .)
    GTGT            reduce using rule 11 (literal -> [ hash_items ] .)
    <               reduce using rule 11 (literal -> [ hash_items ] .)
    LE              reduce using rule 11 (literal -> [ hash_items ] .)
    >               reduce using rule 11 (literal -> [ hash_items ] .)
    GE              reduce using rule 11 (literal -> [ hash_items ] .)
    NE              reduce using rule 11 (literal -> [ hash_items ] .)
    EQ              reduce using rule 11 (literal -> [ hash_items ] .)
    IS              reduce using rule 11 (literal -> [ hash_items ] .)
    IN              reduce using rule 11 (literal -> [ hash_items ] .)
    NOT             reduce using rule 11 (literal -> [ hash_items ] .)
    |               reduce using rule 11 (literal -> [ hash_items ] .)
    AND             reduce using rule 11 (literal -> [ hash_items ] .)
    OR              reduce using rule 11 (literal -> [ hash_items ] .)
    NEWLINE         reduce using rule 11 (literal -> [ hash_items ] .)
    $end            reduce using rule 11 (literal -> [ hash_items ] .)
    ]               reduce using rule 11 (literal -> [ hash_items ] .)
    ,               reduce using rule 11 (literal -> [ hash_items ] .)
    }               reduce using rule 11 (literal -> [ hash_items ] .)
    )               reduce using rule 11 (literal -> [ hash_items ] .)
    {               reduce using rule 11 (literal -> [ hash_items ] .)
    AS              reduce using rule 11 (literal -> [ hash_items ] .)
    :               reduce using rule 11 (literal -> [ hash_items ] .)



state 150

    (8) literal -> [ list_items ] .

    [               reduce using rule 8 (literal -> [ list_items ] .)
    .               reduce using rule 8 (literal -> [ list_items ] .)
    ^               reduce using rule 8 (literal -> [ list_items ] .)
    (               reduce using rule 8 (literal -> [ list_items ] .)
    PLUSPLUS        reduce using rule 8 (literal -> [ list_items ] .)
    MINUSMINUS      reduce using rule 8 (literal -> [ list_items ] .)
    *               reduce using rule 8 (literal -> [ list_items ] .)
    /               reduce using rule 8 (literal -> [ list_items ] .)
    SLASHSLASH      reduce using rule 8 (literal -> [ list_items ] .)
    MOD             reduce using rule 8 (literal -> [ list_items ] .)
    +               reduce using rule 8 (literal -> [ list_items ] .)
    -               reduce using rule 8 (literal -> [ list_items ] .)
    LTLT            reduce using rule 8 (literal -> [ list_items ] .)
    GTGT            reduce using rule 8 (literal -> [ list_items ] .)
    <               reduce using rule 8 (literal -> [ list_items ] .)
    LE              reduce using rule 8 (literal -> [ list_items ] .)
    >               reduce using rule 8 (literal -> [ list_items ] .)
    GE              reduce using rule 8 (literal -> [ list_items ] .)
    NE              reduce using rule 8 (literal -> [ list_items ] .)
    EQ              reduce using rule 8 (literal -> [ list_items ] .)
    IS              reduce using rule 8 (literal -> [ list_items ] .)
    IN              reduce using rule 8 (literal -> [ list_items ] .)
    NOT             reduce using rule 8 (literal -> [ list_items ] .)
    |               reduce using rule 8 (literal -> [ list_items ] .)
    AND             reduce using rule 8 (literal -> [ list_items ] .)
    OR              reduce using rule 8 (literal -> [ list_items ] .)
    NEWLINE         reduce using rule 8 (literal -> [ list_items ] .)
    $end            reduce using rule 8 (literal -> [ list_items ] .)
    ]               reduce using rule 8 (literal -> [ list_items ] .)
    ,               reduce using rule 8 (literal -> [ list_items ] .)
    }               reduce using rule 8 (literal -> [ list_items ] .)
    )               reduce using rule 8 (literal -> [ list_items ] .)
    {               reduce using rule 8 (literal -> [ list_items ] .)
    AS              reduce using rule 8 (literal -> [ list_items ] .)
    :               reduce using rule 8 (literal -> [ list_items ] .)



state 151

    (9) literal -> [ list_items , . ]
    (18) list_items -> list_items , . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    ]               shift and go to state 210
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 211

state 152

    (23) hash_items -> ident : . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 212

state 153

    (135) try_s -> try_try try_catch else .

    }               reduce using rule 135 (try_s -> try_try try_catch else .)
    NEWLINE         reduce using rule 135 (try_s -> try_try try_catch else .)
    $end            reduce using rule 135 (try_s -> try_try try_catch else .)



state 154

    (137) try_catch -> CATCH expression . block try_catch
    (138) try_catch -> CATCH expression . AS ident block try_catch
    (131) block -> . { statements }

    AS              shift and go to state 213
    {               shift and go to state 80


    block                          shift and go to state 214

state 155

    (141) statements -> statements NEWLINE statement .

    }               reduce using rule 141 (statements -> statements NEWLINE statement .)
    NEWLINE         reduce using rule 141 (statements -> statements NEWLINE statement .)
    $end            reduce using rule 141 (statements -> statements NEWLINE statement .)



state 156

    (26) test_and -> test_and AND test_not .

    AND             reduce using rule 26 (test_and -> test_and AND test_not .)
    OR              reduce using rule 26 (test_and -> test_and AND test_not .)
    ,               reduce using rule 26 (test_and -> test_and AND test_not .)
    NEWLINE         reduce using rule 26 (test_and -> test_and AND test_not .)
    $end            reduce using rule 26 (test_and -> test_and AND test_not .)
    }               reduce using rule 26 (test_and -> test_and AND test_not .)
    {               reduce using rule 26 (test_and -> test_and AND test_not .)
    )               reduce using rule 26 (test_and -> test_and AND test_not .)
    AS              reduce using rule 26 (test_and -> test_and AND test_not .)
    :               reduce using rule 26 (test_and -> test_and AND test_not .)
    ]               reduce using rule 26 (test_and -> test_and AND test_not .)



state 157

    (52) test_mdmf -> test_mdmf SLASHSLASH test_un .
    (55) test_un -> test_un . PLUSPLUS
    (56) test_un -> test_un . MINUSMINUS

    *               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    /               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    SLASHSLASH      reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    MOD             reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    +               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    -               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    LTLT            reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    GTGT            reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    <               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    LE              reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    >               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    GE              reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    NE              reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    EQ              reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    IS              reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    IN              reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    NOT             reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    |               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    AND             reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    OR              reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    ,               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    {               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    NEWLINE         reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    $end            reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    )               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    }               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    ]               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    AS              reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    :               reduce using rule 52 (test_mdmf -> test_mdmf SLASHSLASH test_un .)
    PLUSPLUS        shift and go to state 66
    MINUSMINUS      shift and go to state 67



state 158

    (50) test_mdmf -> test_mdmf * test_un .
    (55) test_un -> test_un . PLUSPLUS
    (56) test_un -> test_un . MINUSMINUS

    *               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    /               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    SLASHSLASH      reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    MOD             reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    +               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    -               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    LTLT            reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    GTGT            reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    <               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    LE              reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    >               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    GE              reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    NE              reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    EQ              reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    IS              reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    IN              reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    NOT             reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    |               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    AND             reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    OR              reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    ,               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    {               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    NEWLINE         reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    $end            reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    )               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    }               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    ]               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    AS              reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    :               reduce using rule 50 (test_mdmf -> test_mdmf * test_un .)
    PLUSPLUS        shift and go to state 66
    MINUSMINUS      shift and go to state 67



state 159

    (51) test_mdmf -> test_mdmf / test_un .
    (55) test_un -> test_un . PLUSPLUS
    (56) test_un -> test_un . MINUSMINUS

    *               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    /               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    SLASHSLASH      reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    MOD             reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    +               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    -               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    LTLT            reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    GTGT            reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    <               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    LE              reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    >               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    GE              reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    NE              reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    EQ              reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    IS              reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    IN              reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    NOT             reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    |               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    AND             reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    OR              reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    ,               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    {               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    NEWLINE         reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    $end            reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    )               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    }               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    ]               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    AS              reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    :               reduce using rule 51 (test_mdmf -> test_mdmf / test_un .)
    PLUSPLUS        shift and go to state 66
    MINUSMINUS      shift and go to state 67



state 160

    (53) test_mdmf -> test_mdmf MOD test_un .
    (55) test_un -> test_un . PLUSPLUS
    (56) test_un -> test_un . MINUSMINUS

    *               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    /               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    SLASHSLASH      reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    MOD             reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    +               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    -               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    LTLT            reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    GTGT            reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    <               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    LE              reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    >               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    GE              reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    NE              reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    EQ              reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    IS              reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    IN              reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    NOT             reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    |               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    AND             reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    OR              reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    ,               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    {               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    NEWLINE         reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    $end            reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    )               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    }               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    ]               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    AS              reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    :               reduce using rule 53 (test_mdmf -> test_mdmf MOD test_un .)
    PLUSPLUS        shift and go to state 66
    MINUSMINUS      shift and go to state 67



state 161

    (132) while_s -> WHILE expression block . else
    (129) else -> . ELSE block
    (130) else -> .

    ELSE            shift and go to state 133
    NEWLINE         reduce using rule 130 (else -> .)
    $end            reduce using rule 130 (else -> .)
    }               reduce using rule 130 (else -> .)


    else                           shift and go to state 215

state 162

    (19) list_items -> expression .
    (89) statement -> expression .

  ! reduce/reduce conflict for } resolved using rule 19 (list_items -> expression .).
    }               reduce using rule 19 (list_items -> expression .)
    ,               reduce using rule 19 (list_items -> expression .)
    NEWLINE         reduce using rule 89 (statement -> expression .)

  ! }               [ reduce using rule 89 (statement -> expression .) ]


state 163

    (23) hash_items -> ident . : expression
    (98) declaration -> ident . assignment
    (102) many_idents -> ident .
    (86) test_basis -> ident .
    (97) assignment -> . many_idents EQOP comma_list
    (101) many_idents -> . many_idents , ident
    (102) many_idents -> . ident
    (7) ident -> . IDENT

  ! reduce/reduce conflict for , resolved using rule 86 (test_basis -> ident .).
    :               shift and go to state 152
    EQOP            reduce using rule 102 (many_idents -> ident .)
    [               reduce using rule 86 (test_basis -> ident .)
    .               reduce using rule 86 (test_basis -> ident .)
    ^               reduce using rule 86 (test_basis -> ident .)
    (               reduce using rule 86 (test_basis -> ident .)
    PLUSPLUS        reduce using rule 86 (test_basis -> ident .)
    MINUSMINUS      reduce using rule 86 (test_basis -> ident .)
    *               reduce using rule 86 (test_basis -> ident .)
    /               reduce using rule 86 (test_basis -> ident .)
    SLASHSLASH      reduce using rule 86 (test_basis -> ident .)
    MOD             reduce using rule 86 (test_basis -> ident .)
    +               reduce using rule 86 (test_basis -> ident .)
    -               reduce using rule 86 (test_basis -> ident .)
    LTLT            reduce using rule 86 (test_basis -> ident .)
    GTGT            reduce using rule 86 (test_basis -> ident .)
    <               reduce using rule 86 (test_basis -> ident .)
    LE              reduce using rule 86 (test_basis -> ident .)
    >               reduce using rule 86 (test_basis -> ident .)
    GE              reduce using rule 86 (test_basis -> ident .)
    NE              reduce using rule 86 (test_basis -> ident .)
    EQ              reduce using rule 86 (test_basis -> ident .)
    IS              reduce using rule 86 (test_basis -> ident .)
    IN              reduce using rule 86 (test_basis -> ident .)
    NOT             reduce using rule 86 (test_basis -> ident .)
    |               reduce using rule 86 (test_basis -> ident .)
    AND             reduce using rule 86 (test_basis -> ident .)
    OR              reduce using rule 86 (test_basis -> ident .)
    }               reduce using rule 86 (test_basis -> ident .)
    ,               reduce using rule 86 (test_basis -> ident .)
    NEWLINE         reduce using rule 86 (test_basis -> ident .)
    IDENT           shift and go to state 15

  ! ,               [ reduce using rule 102 (many_idents -> ident .) ]

    assignment                     shift and go to state 115
    many_idents                    shift and go to state 59
    ident                          shift and go to state 74

state 164

    (133) while_s -> WHILE block else .

    }               reduce using rule 133 (while_s -> WHILE block else .)
    NEWLINE         reduce using rule 133 (while_s -> WHILE block else .)
    $end            reduce using rule 133 (while_s -> WHILE block else .)



state 165

    (38) test_comp -> test_comp LE test_io .
    (44) test_io -> test_io . LTLT test_pm
    (45) test_io -> test_io . GTGT test_pm

    <               reduce using rule 38 (test_comp -> test_comp LE test_io .)
    LE              reduce using rule 38 (test_comp -> test_comp LE test_io .)
    >               reduce using rule 38 (test_comp -> test_comp LE test_io .)
    GE              reduce using rule 38 (test_comp -> test_comp LE test_io .)
    NE              reduce using rule 38 (test_comp -> test_comp LE test_io .)
    EQ              reduce using rule 38 (test_comp -> test_comp LE test_io .)
    IS              reduce using rule 38 (test_comp -> test_comp LE test_io .)
    IN              reduce using rule 38 (test_comp -> test_comp LE test_io .)
    NOT             reduce using rule 38 (test_comp -> test_comp LE test_io .)
    |               reduce using rule 38 (test_comp -> test_comp LE test_io .)
    AND             reduce using rule 38 (test_comp -> test_comp LE test_io .)
    OR              reduce using rule 38 (test_comp -> test_comp LE test_io .)
    }               reduce using rule 38 (test_comp -> test_comp LE test_io .)
    ,               reduce using rule 38 (test_comp -> test_comp LE test_io .)
    NEWLINE         reduce using rule 38 (test_comp -> test_comp LE test_io .)
    $end            reduce using rule 38 (test_comp -> test_comp LE test_io .)
    {               reduce using rule 38 (test_comp -> test_comp LE test_io .)
    )               reduce using rule 38 (test_comp -> test_comp LE test_io .)
    ]               reduce using rule 38 (test_comp -> test_comp LE test_io .)
    AS              reduce using rule 38 (test_comp -> test_comp LE test_io .)
    :               reduce using rule 38 (test_comp -> test_comp LE test_io .)
    LTLT            shift and go to state 111
    GTGT            shift and go to state 110



state 166

    (41) test_comp -> test_comp NE test_io .
    (44) test_io -> test_io . LTLT test_pm
    (45) test_io -> test_io . GTGT test_pm

    <               reduce using rule 41 (test_comp -> test_comp NE test_io .)
    LE              reduce using rule 41 (test_comp -> test_comp NE test_io .)
    >               reduce using rule 41 (test_comp -> test_comp NE test_io .)
    GE              reduce using rule 41 (test_comp -> test_comp NE test_io .)
    NE              reduce using rule 41 (test_comp -> test_comp NE test_io .)
    EQ              reduce using rule 41 (test_comp -> test_comp NE test_io .)
    IS              reduce using rule 41 (test_comp -> test_comp NE test_io .)
    IN              reduce using rule 41 (test_comp -> test_comp NE test_io .)
    NOT             reduce using rule 41 (test_comp -> test_comp NE test_io .)
    |               reduce using rule 41 (test_comp -> test_comp NE test_io .)
    AND             reduce using rule 41 (test_comp -> test_comp NE test_io .)
    OR              reduce using rule 41 (test_comp -> test_comp NE test_io .)
    }               reduce using rule 41 (test_comp -> test_comp NE test_io .)
    ,               reduce using rule 41 (test_comp -> test_comp NE test_io .)
    NEWLINE         reduce using rule 41 (test_comp -> test_comp NE test_io .)
    $end            reduce using rule 41 (test_comp -> test_comp NE test_io .)
    {               reduce using rule 41 (test_comp -> test_comp NE test_io .)
    )               reduce using rule 41 (test_comp -> test_comp NE test_io .)
    ]               reduce using rule 41 (test_comp -> test_comp NE test_io .)
    AS              reduce using rule 41 (test_comp -> test_comp NE test_io .)
    :               reduce using rule 41 (test_comp -> test_comp NE test_io .)
    LTLT            shift and go to state 111
    GTGT            shift and go to state 110



state 167

    (40) test_comp -> test_comp GE test_io .
    (44) test_io -> test_io . LTLT test_pm
    (45) test_io -> test_io . GTGT test_pm

    <               reduce using rule 40 (test_comp -> test_comp GE test_io .)
    LE              reduce using rule 40 (test_comp -> test_comp GE test_io .)
    >               reduce using rule 40 (test_comp -> test_comp GE test_io .)
    GE              reduce using rule 40 (test_comp -> test_comp GE test_io .)
    NE              reduce using rule 40 (test_comp -> test_comp GE test_io .)
    EQ              reduce using rule 40 (test_comp -> test_comp GE test_io .)
    IS              reduce using rule 40 (test_comp -> test_comp GE test_io .)
    IN              reduce using rule 40 (test_comp -> test_comp GE test_io .)
    NOT             reduce using rule 40 (test_comp -> test_comp GE test_io .)
    |               reduce using rule 40 (test_comp -> test_comp GE test_io .)
    AND             reduce using rule 40 (test_comp -> test_comp GE test_io .)
    OR              reduce using rule 40 (test_comp -> test_comp GE test_io .)
    }               reduce using rule 40 (test_comp -> test_comp GE test_io .)
    ,               reduce using rule 40 (test_comp -> test_comp GE test_io .)
    NEWLINE         reduce using rule 40 (test_comp -> test_comp GE test_io .)
    $end            reduce using rule 40 (test_comp -> test_comp GE test_io .)
    {               reduce using rule 40 (test_comp -> test_comp GE test_io .)
    )               reduce using rule 40 (test_comp -> test_comp GE test_io .)
    ]               reduce using rule 40 (test_comp -> test_comp GE test_io .)
    AS              reduce using rule 40 (test_comp -> test_comp GE test_io .)
    :               reduce using rule 40 (test_comp -> test_comp GE test_io .)
    LTLT            shift and go to state 111
    GTGT            shift and go to state 110



state 168

    (42) test_comp -> test_comp EQ test_io .
    (44) test_io -> test_io . LTLT test_pm
    (45) test_io -> test_io . GTGT test_pm

    <               reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    LE              reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    >               reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    GE              reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    NE              reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    EQ              reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    IS              reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    IN              reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    NOT             reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    |               reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    AND             reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    OR              reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    }               reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    ,               reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    NEWLINE         reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    $end            reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    {               reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    )               reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    ]               reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    AS              reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    :               reduce using rule 42 (test_comp -> test_comp EQ test_io .)
    LTLT            shift and go to state 111
    GTGT            shift and go to state 110



state 169

    (37) test_comp -> test_comp < test_io .
    (44) test_io -> test_io . LTLT test_pm
    (45) test_io -> test_io . GTGT test_pm

    <               reduce using rule 37 (test_comp -> test_comp < test_io .)
    LE              reduce using rule 37 (test_comp -> test_comp < test_io .)
    >               reduce using rule 37 (test_comp -> test_comp < test_io .)
    GE              reduce using rule 37 (test_comp -> test_comp < test_io .)
    NE              reduce using rule 37 (test_comp -> test_comp < test_io .)
    EQ              reduce using rule 37 (test_comp -> test_comp < test_io .)
    IS              reduce using rule 37 (test_comp -> test_comp < test_io .)
    IN              reduce using rule 37 (test_comp -> test_comp < test_io .)
    NOT             reduce using rule 37 (test_comp -> test_comp < test_io .)
    |               reduce using rule 37 (test_comp -> test_comp < test_io .)
    AND             reduce using rule 37 (test_comp -> test_comp < test_io .)
    OR              reduce using rule 37 (test_comp -> test_comp < test_io .)
    }               reduce using rule 37 (test_comp -> test_comp < test_io .)
    ,               reduce using rule 37 (test_comp -> test_comp < test_io .)
    NEWLINE         reduce using rule 37 (test_comp -> test_comp < test_io .)
    $end            reduce using rule 37 (test_comp -> test_comp < test_io .)
    {               reduce using rule 37 (test_comp -> test_comp < test_io .)
    )               reduce using rule 37 (test_comp -> test_comp < test_io .)
    ]               reduce using rule 37 (test_comp -> test_comp < test_io .)
    AS              reduce using rule 37 (test_comp -> test_comp < test_io .)
    :               reduce using rule 37 (test_comp -> test_comp < test_io .)
    LTLT            shift and go to state 111
    GTGT            shift and go to state 110



state 170

    (39) test_comp -> test_comp > test_io .
    (44) test_io -> test_io . LTLT test_pm
    (45) test_io -> test_io . GTGT test_pm

    <               reduce using rule 39 (test_comp -> test_comp > test_io .)
    LE              reduce using rule 39 (test_comp -> test_comp > test_io .)
    >               reduce using rule 39 (test_comp -> test_comp > test_io .)
    GE              reduce using rule 39 (test_comp -> test_comp > test_io .)
    NE              reduce using rule 39 (test_comp -> test_comp > test_io .)
    EQ              reduce using rule 39 (test_comp -> test_comp > test_io .)
    IS              reduce using rule 39 (test_comp -> test_comp > test_io .)
    IN              reduce using rule 39 (test_comp -> test_comp > test_io .)
    NOT             reduce using rule 39 (test_comp -> test_comp > test_io .)
    |               reduce using rule 39 (test_comp -> test_comp > test_io .)
    AND             reduce using rule 39 (test_comp -> test_comp > test_io .)
    OR              reduce using rule 39 (test_comp -> test_comp > test_io .)
    }               reduce using rule 39 (test_comp -> test_comp > test_io .)
    ,               reduce using rule 39 (test_comp -> test_comp > test_io .)
    NEWLINE         reduce using rule 39 (test_comp -> test_comp > test_io .)
    $end            reduce using rule 39 (test_comp -> test_comp > test_io .)
    {               reduce using rule 39 (test_comp -> test_comp > test_io .)
    )               reduce using rule 39 (test_comp -> test_comp > test_io .)
    ]               reduce using rule 39 (test_comp -> test_comp > test_io .)
    AS              reduce using rule 39 (test_comp -> test_comp > test_io .)
    :               reduce using rule 39 (test_comp -> test_comp > test_io .)
    LTLT            shift and go to state 111
    GTGT            shift and go to state 110



state 171

    (34) test_type -> test_type IS test_comp .
    (37) test_comp -> test_comp . < test_io
    (38) test_comp -> test_comp . LE test_io
    (39) test_comp -> test_comp . > test_io
    (40) test_comp -> test_comp . GE test_io
    (41) test_comp -> test_comp . NE test_io
    (42) test_comp -> test_comp . EQ test_io

    IS              reduce using rule 34 (test_type -> test_type IS test_comp .)
    IN              reduce using rule 34 (test_type -> test_type IS test_comp .)
    NOT             reduce using rule 34 (test_type -> test_type IS test_comp .)
    |               reduce using rule 34 (test_type -> test_type IS test_comp .)
    AND             reduce using rule 34 (test_type -> test_type IS test_comp .)
    OR              reduce using rule 34 (test_type -> test_type IS test_comp .)
    :               reduce using rule 34 (test_type -> test_type IS test_comp .)
    ]               reduce using rule 34 (test_type -> test_type IS test_comp .)
    ,               reduce using rule 34 (test_type -> test_type IS test_comp .)
    }               reduce using rule 34 (test_type -> test_type IS test_comp .)
    NEWLINE         reduce using rule 34 (test_type -> test_type IS test_comp .)
    {               reduce using rule 34 (test_type -> test_type IS test_comp .)
    AS              reduce using rule 34 (test_type -> test_type IS test_comp .)
    $end            reduce using rule 34 (test_type -> test_type IS test_comp .)
    )               reduce using rule 34 (test_type -> test_type IS test_comp .)
    <               shift and go to state 107
    LE              shift and go to state 103
    >               shift and go to state 108
    GE              shift and go to state 105
    NE              shift and go to state 104
    EQ              shift and go to state 106



state 172

    (35) test_type -> test_type IS NOT . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_comp                      shift and go to state 216
    test_sub                       shift and go to state 52

state 173

    (45) test_io -> test_io GTGT test_pm .
    (47) test_pm -> test_pm . + test_mdmf
    (48) test_pm -> test_pm . - test_mdmf

    LTLT            reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    GTGT            reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    <               reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    LE              reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    >               reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    GE              reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    NE              reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    EQ              reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    IS              reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    IN              reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    NOT             reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    |               reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    AND             reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    OR              reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    NEWLINE         reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    $end            reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    }               reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    )               reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    ,               reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    ]               reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    {               reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    AS              reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    :               reduce using rule 45 (test_io -> test_io GTGT test_pm .)
    +               shift and go to state 128
    -               shift and go to state 129



state 174

    (44) test_io -> test_io LTLT test_pm .
    (47) test_pm -> test_pm . + test_mdmf
    (48) test_pm -> test_pm . - test_mdmf

    LTLT            reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    GTGT            reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    <               reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    LE              reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    >               reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    GE              reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    NE              reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    EQ              reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    IS              reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    IN              reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    NOT             reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    |               reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    AND             reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    OR              reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    NEWLINE         reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    $end            reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    }               reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    )               reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    ,               reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    ]               reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    {               reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    AS              reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    :               reduce using rule 44 (test_io -> test_io LTLT test_pm .)
    +               shift and go to state 128
    -               shift and go to state 129



state 175

    (31) test_in -> test_in NOT IN . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_basis                     shift and go to state 51
    test_mdmf                      shift and go to state 31
    test_type                      shift and go to state 217
    ident                          shift and go to state 62
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    literal                        shift and go to state 37
    test_attr                      shift and go to state 58
    test_un                        shift and go to state 5
    test_pm                        shift and go to state 60
    test_comp                      shift and go to state 34
    test_sub                       shift and go to state 52

state 176

    (32) test_in -> test_in | test_type .
    (34) test_type -> test_type . IS test_comp
    (35) test_type -> test_type . IS NOT test_comp

    IN              reduce using rule 32 (test_in -> test_in | test_type .)
    NOT             reduce using rule 32 (test_in -> test_in | test_type .)
    |               reduce using rule 32 (test_in -> test_in | test_type .)
    AND             reduce using rule 32 (test_in -> test_in | test_type .)
    OR              reduce using rule 32 (test_in -> test_in | test_type .)
    ,               reduce using rule 32 (test_in -> test_in | test_type .)
    NEWLINE         reduce using rule 32 (test_in -> test_in | test_type .)
    $end            reduce using rule 32 (test_in -> test_in | test_type .)
    }               reduce using rule 32 (test_in -> test_in | test_type .)
    {               reduce using rule 32 (test_in -> test_in | test_type .)
    )               reduce using rule 32 (test_in -> test_in | test_type .)
    ]               reduce using rule 32 (test_in -> test_in | test_type .)
    :               reduce using rule 32 (test_in -> test_in | test_type .)
    AS              reduce using rule 32 (test_in -> test_in | test_type .)
    IS              shift and go to state 109



state 177

    (30) test_in -> test_in IN test_type .
    (34) test_type -> test_type . IS test_comp
    (35) test_type -> test_type . IS NOT test_comp

    IN              reduce using rule 30 (test_in -> test_in IN test_type .)
    NOT             reduce using rule 30 (test_in -> test_in IN test_type .)
    |               reduce using rule 30 (test_in -> test_in IN test_type .)
    AND             reduce using rule 30 (test_in -> test_in IN test_type .)
    OR              reduce using rule 30 (test_in -> test_in IN test_type .)
    ,               reduce using rule 30 (test_in -> test_in IN test_type .)
    NEWLINE         reduce using rule 30 (test_in -> test_in IN test_type .)
    $end            reduce using rule 30 (test_in -> test_in IN test_type .)
    }               reduce using rule 30 (test_in -> test_in IN test_type .)
    {               reduce using rule 30 (test_in -> test_in IN test_type .)
    )               reduce using rule 30 (test_in -> test_in IN test_type .)
    ]               reduce using rule 30 (test_in -> test_in IN test_type .)
    :               reduce using rule 30 (test_in -> test_in IN test_type .)
    AS              reduce using rule 30 (test_in -> test_in IN test_type .)
    IS              shift and go to state 109



state 178

    (120) assert_s -> ASSERT expression , . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 218

state 179

    (78) index -> indice .

    ]               reduce using rule 78 (index -> indice .)
    ,               reduce using rule 78 (index -> indice .)



state 180

    (74) test_sub -> test_sub [ index . ]
    (75) test_sub -> test_sub [ index . , ]
    (77) index -> index . , indice

    ]               shift and go to state 220
    ,               shift and go to state 219



state 181

    (82) indice -> DOTDOTDOT .

    ]               reduce using rule 82 (indice -> DOTDOTDOT .)
    ,               reduce using rule 82 (indice -> DOTDOTDOT .)



state 182

    (79) indice -> expression . : expression : expression
    (80) indice -> expression . : expression
    (81) indice -> expression .

    :               shift and go to state 221
    ]               reduce using rule 81 (indice -> expression .)
    ,               reduce using rule 81 (indice -> expression .)



state 183

    (109) flow_s -> YIELD comma_list , .
    (112) comma_list -> comma_list , . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    }               reduce using rule 109 (flow_s -> YIELD comma_list , .)
    NEWLINE         reduce using rule 109 (flow_s -> YIELD comma_list , .)
    $end            reduce using rule 109 (flow_s -> YIELD comma_list , .)
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 198

state 184

    (16) literal -> { hash_items , . }
    (20) hash_items -> hash_items , . primitive : expression
    (21) hash_items -> hash_items , . ident : expression
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (7) ident -> . IDENT

    }               shift and go to state 222
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    IDENT           shift and go to state 15


    primitive                      shift and go to state 207
    ident                          shift and go to state 208

state 185

    (15) literal -> { hash_items } .

    [               reduce using rule 15 (literal -> { hash_items } .)
    .               reduce using rule 15 (literal -> { hash_items } .)
    ^               reduce using rule 15 (literal -> { hash_items } .)
    (               reduce using rule 15 (literal -> { hash_items } .)
    PLUSPLUS        reduce using rule 15 (literal -> { hash_items } .)
    MINUSMINUS      reduce using rule 15 (literal -> { hash_items } .)
    *               reduce using rule 15 (literal -> { hash_items } .)
    /               reduce using rule 15 (literal -> { hash_items } .)
    SLASHSLASH      reduce using rule 15 (literal -> { hash_items } .)
    MOD             reduce using rule 15 (literal -> { hash_items } .)
    +               reduce using rule 15 (literal -> { hash_items } .)
    -               reduce using rule 15 (literal -> { hash_items } .)
    LTLT            reduce using rule 15 (literal -> { hash_items } .)
    GTGT            reduce using rule 15 (literal -> { hash_items } .)
    <               reduce using rule 15 (literal -> { hash_items } .)
    LE              reduce using rule 15 (literal -> { hash_items } .)
    >               reduce using rule 15 (literal -> { hash_items } .)
    GE              reduce using rule 15 (literal -> { hash_items } .)
    NE              reduce using rule 15 (literal -> { hash_items } .)
    EQ              reduce using rule 15 (literal -> { hash_items } .)
    IS              reduce using rule 15 (literal -> { hash_items } .)
    IN              reduce using rule 15 (literal -> { hash_items } .)
    NOT             reduce using rule 15 (literal -> { hash_items } .)
    |               reduce using rule 15 (literal -> { hash_items } .)
    AND             reduce using rule 15 (literal -> { hash_items } .)
    OR              reduce using rule 15 (literal -> { hash_items } .)
    NEWLINE         reduce using rule 15 (literal -> { hash_items } .)
    $end            reduce using rule 15 (literal -> { hash_items } .)
    ]               reduce using rule 15 (literal -> { hash_items } .)
    ,               reduce using rule 15 (literal -> { hash_items } .)
    }               reduce using rule 15 (literal -> { hash_items } .)
    )               reduce using rule 15 (literal -> { hash_items } .)
    {               reduce using rule 15 (literal -> { hash_items } .)
    AS              reduce using rule 15 (literal -> { hash_items } .)
    :               reduce using rule 15 (literal -> { hash_items } .)



state 186

    (13) literal -> { list_items } .

    [               reduce using rule 13 (literal -> { list_items } .)
    .               reduce using rule 13 (literal -> { list_items } .)
    ^               reduce using rule 13 (literal -> { list_items } .)
    (               reduce using rule 13 (literal -> { list_items } .)
    PLUSPLUS        reduce using rule 13 (literal -> { list_items } .)
    MINUSMINUS      reduce using rule 13 (literal -> { list_items } .)
    *               reduce using rule 13 (literal -> { list_items } .)
    /               reduce using rule 13 (literal -> { list_items } .)
    SLASHSLASH      reduce using rule 13 (literal -> { list_items } .)
    MOD             reduce using rule 13 (literal -> { list_items } .)
    +               reduce using rule 13 (literal -> { list_items } .)
    -               reduce using rule 13 (literal -> { list_items } .)
    LTLT            reduce using rule 13 (literal -> { list_items } .)
    GTGT            reduce using rule 13 (literal -> { list_items } .)
    <               reduce using rule 13 (literal -> { list_items } .)
    LE              reduce using rule 13 (literal -> { list_items } .)
    >               reduce using rule 13 (literal -> { list_items } .)
    GE              reduce using rule 13 (literal -> { list_items } .)
    NE              reduce using rule 13 (literal -> { list_items } .)
    EQ              reduce using rule 13 (literal -> { list_items } .)
    IS              reduce using rule 13 (literal -> { list_items } .)
    IN              reduce using rule 13 (literal -> { list_items } .)
    NOT             reduce using rule 13 (literal -> { list_items } .)
    |               reduce using rule 13 (literal -> { list_items } .)
    AND             reduce using rule 13 (literal -> { list_items } .)
    OR              reduce using rule 13 (literal -> { list_items } .)
    NEWLINE         reduce using rule 13 (literal -> { list_items } .)
    $end            reduce using rule 13 (literal -> { list_items } .)
    ]               reduce using rule 13 (literal -> { list_items } .)
    ,               reduce using rule 13 (literal -> { list_items } .)
    }               reduce using rule 13 (literal -> { list_items } .)
    )               reduce using rule 13 (literal -> { list_items } .)
    {               reduce using rule 13 (literal -> { list_items } .)
    AS              reduce using rule 13 (literal -> { list_items } .)
    :               reduce using rule 13 (literal -> { list_items } .)



state 187

    (14) literal -> { list_items , . }
    (18) list_items -> list_items , . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    }               shift and go to state 223
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 211

state 188

    (126) if_if -> IF expression block .

    ELIF            reduce using rule 126 (if_if -> IF expression block .)
    ELSE            reduce using rule 126 (if_if -> IF expression block .)
    NEWLINE         reduce using rule 126 (if_if -> IF expression block .)
    $end            reduce using rule 126 (if_if -> IF expression block .)
    }               reduce using rule 126 (if_if -> IF expression block .)



state 189

    (72) test_attr -> test_attr . test_sub .
    (74) test_sub -> test_sub . [ index ]
    (75) test_sub -> test_sub . [ index , ]

    .               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    ^               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    (               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    PLUSPLUS        reduce using rule 72 (test_attr -> test_attr . test_sub .)
    MINUSMINUS      reduce using rule 72 (test_attr -> test_attr . test_sub .)
    *               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    /               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    SLASHSLASH      reduce using rule 72 (test_attr -> test_attr . test_sub .)
    MOD             reduce using rule 72 (test_attr -> test_attr . test_sub .)
    +               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    -               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    LTLT            reduce using rule 72 (test_attr -> test_attr . test_sub .)
    GTGT            reduce using rule 72 (test_attr -> test_attr . test_sub .)
    <               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    LE              reduce using rule 72 (test_attr -> test_attr . test_sub .)
    >               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    GE              reduce using rule 72 (test_attr -> test_attr . test_sub .)
    NE              reduce using rule 72 (test_attr -> test_attr . test_sub .)
    EQ              reduce using rule 72 (test_attr -> test_attr . test_sub .)
    IS              reduce using rule 72 (test_attr -> test_attr . test_sub .)
    IN              reduce using rule 72 (test_attr -> test_attr . test_sub .)
    NOT             reduce using rule 72 (test_attr -> test_attr . test_sub .)
    |               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    AND             reduce using rule 72 (test_attr -> test_attr . test_sub .)
    OR              reduce using rule 72 (test_attr -> test_attr . test_sub .)
    {               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    NEWLINE         reduce using rule 72 (test_attr -> test_attr . test_sub .)
    $end            reduce using rule 72 (test_attr -> test_attr . test_sub .)
    )               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    ,               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    }               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    ]               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    AS              reduce using rule 72 (test_attr -> test_attr . test_sub .)
    :               reduce using rule 72 (test_attr -> test_attr . test_sub .)
    [               shift and go to state 119



state 190

    (97) assignment -> many_idents EQOP comma_list .
    (112) comma_list -> comma_list . , expression

    }               reduce using rule 97 (assignment -> many_idents EQOP comma_list .)
    NEWLINE         reduce using rule 97 (assignment -> many_idents EQOP comma_list .)
    $end            reduce using rule 97 (assignment -> many_idents EQOP comma_list .)
    ,               shift and go to state 224



state 191

    (101) many_idents -> many_idents , ident .

    ,               reduce using rule 101 (many_idents -> many_idents , ident .)
    NEWLINE         reduce using rule 101 (many_idents -> many_idents , ident .)
    $end            reduce using rule 101 (many_idents -> many_idents , ident .)
    }               reduce using rule 101 (many_idents -> many_idents , ident .)
    EQOP            reduce using rule 101 (many_idents -> many_idents , ident .)
    IN              reduce using rule 101 (many_idents -> many_idents , ident .)



state 192

    (47) test_pm -> test_pm + test_mdmf .
    (50) test_mdmf -> test_mdmf . * test_un
    (51) test_mdmf -> test_mdmf . / test_un
    (52) test_mdmf -> test_mdmf . SLASHSLASH test_un
    (53) test_mdmf -> test_mdmf . MOD test_un

    +               reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    -               reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    LTLT            reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    GTGT            reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    <               reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    LE              reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    >               reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    GE              reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    NE              reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    EQ              reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    IS              reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    IN              reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    NOT             reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    |               reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    AND             reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    OR              reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    NEWLINE         reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    $end            reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    }               reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    ]               reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    ,               reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    )               reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    {               reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    AS              reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    :               reduce using rule 47 (test_pm -> test_pm + test_mdmf .)
    *               shift and go to state 96
    /               shift and go to state 97
    SLASHSLASH      shift and go to state 95
    MOD             shift and go to state 98



state 193

    (48) test_pm -> test_pm - test_mdmf .
    (50) test_mdmf -> test_mdmf . * test_un
    (51) test_mdmf -> test_mdmf . / test_un
    (52) test_mdmf -> test_mdmf . SLASHSLASH test_un
    (53) test_mdmf -> test_mdmf . MOD test_un

    +               reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    -               reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    LTLT            reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    GTGT            reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    <               reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    LE              reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    >               reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    GE              reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    NE              reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    EQ              reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    IS              reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    IN              reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    NOT             reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    |               reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    AND             reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    OR              reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    NEWLINE         reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    $end            reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    }               reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    ]               reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    ,               reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    )               reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    {               reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    AS              reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    :               reduce using rule 48 (test_pm -> test_pm - test_mdmf .)
    *               shift and go to state 96
    /               shift and go to state 97
    SLASHSLASH      shift and go to state 95
    MOD             shift and go to state 98



state 194

    (127) if_elifs -> ELIF expression block . if_elifs
    (127) if_elifs -> . ELIF expression block if_elifs
    (128) if_elifs -> .

    ELIF            shift and go to state 64
    ELSE            reduce using rule 128 (if_elifs -> .)
    NEWLINE         reduce using rule 128 (if_elifs -> .)
    $end            reduce using rule 128 (if_elifs -> .)
    }               reduce using rule 128 (if_elifs -> .)


    if_elifs                       shift and go to state 225

state 195

    (129) else -> ELSE block .

    NEWLINE         reduce using rule 129 (else -> ELSE block .)
    $end            reduce using rule 129 (else -> ELSE block .)
    }               reduce using rule 129 (else -> ELSE block .)



state 196

    (116) import_items -> ident . import_items .

    AS              reduce using rule 116 (import_items -> ident . import_items .)
    NEWLINE         reduce using rule 116 (import_items -> ident . import_items .)
    $end            reduce using rule 116 (import_items -> ident . import_items .)
    }               reduce using rule 116 (import_items -> ident . import_items .)



state 197

    (115) import_s -> IMPORT import_items AS ident .

    NEWLINE         reduce using rule 115 (import_s -> IMPORT import_items AS ident .)
    $end            reduce using rule 115 (import_s -> IMPORT import_items AS ident .)
    }               reduce using rule 115 (import_s -> IMPORT import_items AS ident .)



state 198

    (112) comma_list -> comma_list , expression .

    ,               reduce using rule 112 (comma_list -> comma_list , expression .)
    NEWLINE         reduce using rule 112 (comma_list -> comma_list , expression .)
    $end            reduce using rule 112 (comma_list -> comma_list , expression .)
    }               reduce using rule 112 (comma_list -> comma_list , expression .)
    {               reduce using rule 112 (comma_list -> comma_list , expression .)



state 199

    (134) for_s -> FOR many_idents IN comma_list . block else
    (112) comma_list -> comma_list . , expression
    (131) block -> . { statements }

    ,               shift and go to state 224
    {               shift and go to state 80


    block                          shift and go to state 226

state 200

    (62) test_call -> test_call ( arglist ) .

    ^               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    (               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    PLUSPLUS        reduce using rule 62 (test_call -> test_call ( arglist ) .)
    MINUSMINUS      reduce using rule 62 (test_call -> test_call ( arglist ) .)
    *               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    /               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    SLASHSLASH      reduce using rule 62 (test_call -> test_call ( arglist ) .)
    MOD             reduce using rule 62 (test_call -> test_call ( arglist ) .)
    +               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    -               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    LTLT            reduce using rule 62 (test_call -> test_call ( arglist ) .)
    GTGT            reduce using rule 62 (test_call -> test_call ( arglist ) .)
    <               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    LE              reduce using rule 62 (test_call -> test_call ( arglist ) .)
    >               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    GE              reduce using rule 62 (test_call -> test_call ( arglist ) .)
    NE              reduce using rule 62 (test_call -> test_call ( arglist ) .)
    EQ              reduce using rule 62 (test_call -> test_call ( arglist ) .)
    IS              reduce using rule 62 (test_call -> test_call ( arglist ) .)
    IN              reduce using rule 62 (test_call -> test_call ( arglist ) .)
    NOT             reduce using rule 62 (test_call -> test_call ( arglist ) .)
    |               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    AND             reduce using rule 62 (test_call -> test_call ( arglist ) .)
    OR              reduce using rule 62 (test_call -> test_call ( arglist ) .)
    ]               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    ,               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    )               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    }               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    NEWLINE         reduce using rule 62 (test_call -> test_call ( arglist ) .)
    $end            reduce using rule 62 (test_call -> test_call ( arglist ) .)
    {               reduce using rule 62 (test_call -> test_call ( arglist ) .)
    AS              reduce using rule 62 (test_call -> test_call ( arglist ) .)
    :               reduce using rule 62 (test_call -> test_call ( arglist ) .)



state 201

    (63) test_call -> test_call ( arglist , . )
    (65) arglist -> arglist , . arg
    (68) arg -> . expression
    (69) arg -> . ident = expression
    (70) arg -> . * ident
    (71) arg -> . * * ident
    (88) expression -> . test_or
    (7) ident -> . IDENT
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }

    )               shift and go to state 228
    *               shift and go to state 142
    IDENT           shift and go to state 15
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    arg                            shift and go to state 227
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 143
    test_pm                        shift and go to state 60
    expression                     shift and go to state 144

state 202

    (70) arg -> * ident .

    )               reduce using rule 70 (arg -> * ident .)
    ,               reduce using rule 70 (arg -> * ident .)



state 203

    (71) arg -> * * . ident
    (7) ident -> . IDENT

    IDENT           shift and go to state 15


    ident                          shift and go to state 229

state 204

    (69) arg -> ident = . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 230

state 205

    (131) block -> { statements } .

    ELSE            reduce using rule 131 (block -> { statements } .)
    NEWLINE         reduce using rule 131 (block -> { statements } .)
    $end            reduce using rule 131 (block -> { statements } .)
    }               reduce using rule 131 (block -> { statements } .)
    CATCH           reduce using rule 131 (block -> { statements } .)
    ELIF            reduce using rule 131 (block -> { statements } .)



state 206

    (22) hash_items -> primitive : expression .

    ]               reduce using rule 22 (hash_items -> primitive : expression .)
    ,               reduce using rule 22 (hash_items -> primitive : expression .)
    }               reduce using rule 22 (hash_items -> primitive : expression .)



state 207

    (20) hash_items -> hash_items , primitive . : expression

    :               shift and go to state 231



state 208

    (21) hash_items -> hash_items , ident . : expression

    :               shift and go to state 232



state 209

    (12) literal -> [ hash_items , ] .

    [               reduce using rule 12 (literal -> [ hash_items , ] .)
    .               reduce using rule 12 (literal -> [ hash_items , ] .)
    ^               reduce using rule 12 (literal -> [ hash_items , ] .)
    (               reduce using rule 12 (literal -> [ hash_items , ] .)
    PLUSPLUS        reduce using rule 12 (literal -> [ hash_items , ] .)
    MINUSMINUS      reduce using rule 12 (literal -> [ hash_items , ] .)
    *               reduce using rule 12 (literal -> [ hash_items , ] .)
    /               reduce using rule 12 (literal -> [ hash_items , ] .)
    SLASHSLASH      reduce using rule 12 (literal -> [ hash_items , ] .)
    MOD             reduce using rule 12 (literal -> [ hash_items , ] .)
    +               reduce using rule 12 (literal -> [ hash_items , ] .)
    -               reduce using rule 12 (literal -> [ hash_items , ] .)
    LTLT            reduce using rule 12 (literal -> [ hash_items , ] .)
    GTGT            reduce using rule 12 (literal -> [ hash_items , ] .)
    <               reduce using rule 12 (literal -> [ hash_items , ] .)
    LE              reduce using rule 12 (literal -> [ hash_items , ] .)
    >               reduce using rule 12 (literal -> [ hash_items , ] .)
    GE              reduce using rule 12 (literal -> [ hash_items , ] .)
    NE              reduce using rule 12 (literal -> [ hash_items , ] .)
    EQ              reduce using rule 12 (literal -> [ hash_items , ] .)
    IS              reduce using rule 12 (literal -> [ hash_items , ] .)
    IN              reduce using rule 12 (literal -> [ hash_items , ] .)
    NOT             reduce using rule 12 (literal -> [ hash_items , ] .)
    |               reduce using rule 12 (literal -> [ hash_items , ] .)
    AND             reduce using rule 12 (literal -> [ hash_items , ] .)
    OR              reduce using rule 12 (literal -> [ hash_items , ] .)
    NEWLINE         reduce using rule 12 (literal -> [ hash_items , ] .)
    $end            reduce using rule 12 (literal -> [ hash_items , ] .)
    ]               reduce using rule 12 (literal -> [ hash_items , ] .)
    ,               reduce using rule 12 (literal -> [ hash_items , ] .)
    }               reduce using rule 12 (literal -> [ hash_items , ] .)
    )               reduce using rule 12 (literal -> [ hash_items , ] .)
    {               reduce using rule 12 (literal -> [ hash_items , ] .)
    AS              reduce using rule 12 (literal -> [ hash_items , ] .)
    :               reduce using rule 12 (literal -> [ hash_items , ] .)



state 210

    (9) literal -> [ list_items , ] .

    [               reduce using rule 9 (literal -> [ list_items , ] .)
    .               reduce using rule 9 (literal -> [ list_items , ] .)
    ^               reduce using rule 9 (literal -> [ list_items , ] .)
    (               reduce using rule 9 (literal -> [ list_items , ] .)
    PLUSPLUS        reduce using rule 9 (literal -> [ list_items , ] .)
    MINUSMINUS      reduce using rule 9 (literal -> [ list_items , ] .)
    *               reduce using rule 9 (literal -> [ list_items , ] .)
    /               reduce using rule 9 (literal -> [ list_items , ] .)
    SLASHSLASH      reduce using rule 9 (literal -> [ list_items , ] .)
    MOD             reduce using rule 9 (literal -> [ list_items , ] .)
    +               reduce using rule 9 (literal -> [ list_items , ] .)
    -               reduce using rule 9 (literal -> [ list_items , ] .)
    LTLT            reduce using rule 9 (literal -> [ list_items , ] .)
    GTGT            reduce using rule 9 (literal -> [ list_items , ] .)
    <               reduce using rule 9 (literal -> [ list_items , ] .)
    LE              reduce using rule 9 (literal -> [ list_items , ] .)
    >               reduce using rule 9 (literal -> [ list_items , ] .)
    GE              reduce using rule 9 (literal -> [ list_items , ] .)
    NE              reduce using rule 9 (literal -> [ list_items , ] .)
    EQ              reduce using rule 9 (literal -> [ list_items , ] .)
    IS              reduce using rule 9 (literal -> [ list_items , ] .)
    IN              reduce using rule 9 (literal -> [ list_items , ] .)
    NOT             reduce using rule 9 (literal -> [ list_items , ] .)
    |               reduce using rule 9 (literal -> [ list_items , ] .)
    AND             reduce using rule 9 (literal -> [ list_items , ] .)
    OR              reduce using rule 9 (literal -> [ list_items , ] .)
    NEWLINE         reduce using rule 9 (literal -> [ list_items , ] .)
    $end            reduce using rule 9 (literal -> [ list_items , ] .)
    ]               reduce using rule 9 (literal -> [ list_items , ] .)
    ,               reduce using rule 9 (literal -> [ list_items , ] .)
    }               reduce using rule 9 (literal -> [ list_items , ] .)
    )               reduce using rule 9 (literal -> [ list_items , ] .)
    {               reduce using rule 9 (literal -> [ list_items , ] .)
    AS              reduce using rule 9 (literal -> [ list_items , ] .)
    :               reduce using rule 9 (literal -> [ list_items , ] .)



state 211

    (18) list_items -> list_items , expression .

    ]               reduce using rule 18 (list_items -> list_items , expression .)
    ,               reduce using rule 18 (list_items -> list_items , expression .)
    }               reduce using rule 18 (list_items -> list_items , expression .)



state 212

    (23) hash_items -> ident : expression .

    ]               reduce using rule 23 (hash_items -> ident : expression .)
    ,               reduce using rule 23 (hash_items -> ident : expression .)
    }               reduce using rule 23 (hash_items -> ident : expression .)



state 213

    (138) try_catch -> CATCH expression AS . ident block try_catch
    (7) ident -> . IDENT

    IDENT           shift and go to state 15


    ident                          shift and go to state 233

state 214

    (137) try_catch -> CATCH expression block . try_catch
    (137) try_catch -> . CATCH expression block try_catch
    (138) try_catch -> . CATCH expression AS ident block try_catch
    (139) try_catch -> .

    CATCH           shift and go to state 92
    ELSE            reduce using rule 139 (try_catch -> .)
    NEWLINE         reduce using rule 139 (try_catch -> .)
    $end            reduce using rule 139 (try_catch -> .)
    }               reduce using rule 139 (try_catch -> .)


    try_catch                      shift and go to state 234

state 215

    (132) while_s -> WHILE expression block else .

    }               reduce using rule 132 (while_s -> WHILE expression block else .)
    NEWLINE         reduce using rule 132 (while_s -> WHILE expression block else .)
    $end            reduce using rule 132 (while_s -> WHILE expression block else .)



state 216

    (35) test_type -> test_type IS NOT test_comp .
    (37) test_comp -> test_comp . < test_io
    (38) test_comp -> test_comp . LE test_io
    (39) test_comp -> test_comp . > test_io
    (40) test_comp -> test_comp . GE test_io
    (41) test_comp -> test_comp . NE test_io
    (42) test_comp -> test_comp . EQ test_io

    IS              reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    IN              reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    NOT             reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    |               reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    AND             reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    OR              reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    :               reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    ]               reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    ,               reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    }               reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    NEWLINE         reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    {               reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    AS              reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    $end            reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    )               reduce using rule 35 (test_type -> test_type IS NOT test_comp .)
    <               shift and go to state 107
    LE              shift and go to state 103
    >               shift and go to state 108
    GE              shift and go to state 105
    NE              shift and go to state 104
    EQ              shift and go to state 106



state 217

    (31) test_in -> test_in NOT IN test_type .
    (34) test_type -> test_type . IS test_comp
    (35) test_type -> test_type . IS NOT test_comp

    IN              reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    NOT             reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    |               reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    AND             reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    OR              reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    ,               reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    NEWLINE         reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    $end            reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    }               reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    {               reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    )               reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    ]               reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    :               reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    AS              reduce using rule 31 (test_in -> test_in NOT IN test_type .)
    IS              shift and go to state 109



state 218

    (120) assert_s -> ASSERT expression , expression .

    NEWLINE         reduce using rule 120 (assert_s -> ASSERT expression , expression .)
    $end            reduce using rule 120 (assert_s -> ASSERT expression , expression .)
    }               reduce using rule 120 (assert_s -> ASSERT expression , expression .)



state 219

    (75) test_sub -> test_sub [ index , . ]
    (77) index -> index , . indice
    (79) indice -> . expression : expression : expression
    (80) indice -> . expression : expression
    (81) indice -> . expression
    (82) indice -> . DOTDOTDOT
    (83) indice -> .
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

  ! shift/reduce conflict for ] resolved as shift.
    ]               shift and go to state 236
    DOTDOTDOT       shift and go to state 181
    ,               reduce using rule 83 (indice -> .)
    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15

  ! ]               [ reduce using rule 83 (indice -> .) ]

    indice                         shift and go to state 235
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    primitive                      shift and go to state 28
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 182

state 220

    (74) test_sub -> test_sub [ index ] .

    [               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    .               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    ^               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    (               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    PLUSPLUS        reduce using rule 74 (test_sub -> test_sub [ index ] .)
    MINUSMINUS      reduce using rule 74 (test_sub -> test_sub [ index ] .)
    *               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    /               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    SLASHSLASH      reduce using rule 74 (test_sub -> test_sub [ index ] .)
    MOD             reduce using rule 74 (test_sub -> test_sub [ index ] .)
    +               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    -               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    LTLT            reduce using rule 74 (test_sub -> test_sub [ index ] .)
    GTGT            reduce using rule 74 (test_sub -> test_sub [ index ] .)
    <               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    LE              reduce using rule 74 (test_sub -> test_sub [ index ] .)
    >               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    GE              reduce using rule 74 (test_sub -> test_sub [ index ] .)
    NE              reduce using rule 74 (test_sub -> test_sub [ index ] .)
    EQ              reduce using rule 74 (test_sub -> test_sub [ index ] .)
    IS              reduce using rule 74 (test_sub -> test_sub [ index ] .)
    IN              reduce using rule 74 (test_sub -> test_sub [ index ] .)
    NOT             reduce using rule 74 (test_sub -> test_sub [ index ] .)
    |               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    AND             reduce using rule 74 (test_sub -> test_sub [ index ] .)
    OR              reduce using rule 74 (test_sub -> test_sub [ index ] .)
    NEWLINE         reduce using rule 74 (test_sub -> test_sub [ index ] .)
    $end            reduce using rule 74 (test_sub -> test_sub [ index ] .)
    )               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    ,               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    }               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    ]               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    {               reduce using rule 74 (test_sub -> test_sub [ index ] .)
    AS              reduce using rule 74 (test_sub -> test_sub [ index ] .)
    :               reduce using rule 74 (test_sub -> test_sub [ index ] .)



state 221

    (79) indice -> expression : . expression : expression
    (80) indice -> expression : . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 237

state 222

    (16) literal -> { hash_items , } .

    [               reduce using rule 16 (literal -> { hash_items , } .)
    .               reduce using rule 16 (literal -> { hash_items , } .)
    ^               reduce using rule 16 (literal -> { hash_items , } .)
    (               reduce using rule 16 (literal -> { hash_items , } .)
    PLUSPLUS        reduce using rule 16 (literal -> { hash_items , } .)
    MINUSMINUS      reduce using rule 16 (literal -> { hash_items , } .)
    *               reduce using rule 16 (literal -> { hash_items , } .)
    /               reduce using rule 16 (literal -> { hash_items , } .)
    SLASHSLASH      reduce using rule 16 (literal -> { hash_items , } .)
    MOD             reduce using rule 16 (literal -> { hash_items , } .)
    +               reduce using rule 16 (literal -> { hash_items , } .)
    -               reduce using rule 16 (literal -> { hash_items , } .)
    LTLT            reduce using rule 16 (literal -> { hash_items , } .)
    GTGT            reduce using rule 16 (literal -> { hash_items , } .)
    <               reduce using rule 16 (literal -> { hash_items , } .)
    LE              reduce using rule 16 (literal -> { hash_items , } .)
    >               reduce using rule 16 (literal -> { hash_items , } .)
    GE              reduce using rule 16 (literal -> { hash_items , } .)
    NE              reduce using rule 16 (literal -> { hash_items , } .)
    EQ              reduce using rule 16 (literal -> { hash_items , } .)
    IS              reduce using rule 16 (literal -> { hash_items , } .)
    IN              reduce using rule 16 (literal -> { hash_items , } .)
    NOT             reduce using rule 16 (literal -> { hash_items , } .)
    |               reduce using rule 16 (literal -> { hash_items , } .)
    AND             reduce using rule 16 (literal -> { hash_items , } .)
    OR              reduce using rule 16 (literal -> { hash_items , } .)
    NEWLINE         reduce using rule 16 (literal -> { hash_items , } .)
    $end            reduce using rule 16 (literal -> { hash_items , } .)
    ]               reduce using rule 16 (literal -> { hash_items , } .)
    ,               reduce using rule 16 (literal -> { hash_items , } .)
    }               reduce using rule 16 (literal -> { hash_items , } .)
    )               reduce using rule 16 (literal -> { hash_items , } .)
    {               reduce using rule 16 (literal -> { hash_items , } .)
    AS              reduce using rule 16 (literal -> { hash_items , } .)
    :               reduce using rule 16 (literal -> { hash_items , } .)



state 223

    (14) literal -> { list_items , } .

    [               reduce using rule 14 (literal -> { list_items , } .)
    .               reduce using rule 14 (literal -> { list_items , } .)
    ^               reduce using rule 14 (literal -> { list_items , } .)
    (               reduce using rule 14 (literal -> { list_items , } .)
    PLUSPLUS        reduce using rule 14 (literal -> { list_items , } .)
    MINUSMINUS      reduce using rule 14 (literal -> { list_items , } .)
    *               reduce using rule 14 (literal -> { list_items , } .)
    /               reduce using rule 14 (literal -> { list_items , } .)
    SLASHSLASH      reduce using rule 14 (literal -> { list_items , } .)
    MOD             reduce using rule 14 (literal -> { list_items , } .)
    +               reduce using rule 14 (literal -> { list_items , } .)
    -               reduce using rule 14 (literal -> { list_items , } .)
    LTLT            reduce using rule 14 (literal -> { list_items , } .)
    GTGT            reduce using rule 14 (literal -> { list_items , } .)
    <               reduce using rule 14 (literal -> { list_items , } .)
    LE              reduce using rule 14 (literal -> { list_items , } .)
    >               reduce using rule 14 (literal -> { list_items , } .)
    GE              reduce using rule 14 (literal -> { list_items , } .)
    NE              reduce using rule 14 (literal -> { list_items , } .)
    EQ              reduce using rule 14 (literal -> { list_items , } .)
    IS              reduce using rule 14 (literal -> { list_items , } .)
    IN              reduce using rule 14 (literal -> { list_items , } .)
    NOT             reduce using rule 14 (literal -> { list_items , } .)
    |               reduce using rule 14 (literal -> { list_items , } .)
    AND             reduce using rule 14 (literal -> { list_items , } .)
    OR              reduce using rule 14 (literal -> { list_items , } .)
    NEWLINE         reduce using rule 14 (literal -> { list_items , } .)
    $end            reduce using rule 14 (literal -> { list_items , } .)
    ]               reduce using rule 14 (literal -> { list_items , } .)
    ,               reduce using rule 14 (literal -> { list_items , } .)
    }               reduce using rule 14 (literal -> { list_items , } .)
    )               reduce using rule 14 (literal -> { list_items , } .)
    {               reduce using rule 14 (literal -> { list_items , } .)
    AS              reduce using rule 14 (literal -> { list_items , } .)
    :               reduce using rule 14 (literal -> { list_items , } .)



state 224

    (112) comma_list -> comma_list , . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 198

state 225

    (127) if_elifs -> ELIF expression block if_elifs .

    ELSE            reduce using rule 127 (if_elifs -> ELIF expression block if_elifs .)
    NEWLINE         reduce using rule 127 (if_elifs -> ELIF expression block if_elifs .)
    $end            reduce using rule 127 (if_elifs -> ELIF expression block if_elifs .)
    }               reduce using rule 127 (if_elifs -> ELIF expression block if_elifs .)



state 226

    (134) for_s -> FOR many_idents IN comma_list block . else
    (129) else -> . ELSE block
    (130) else -> .

    ELSE            shift and go to state 133
    NEWLINE         reduce using rule 130 (else -> .)
    $end            reduce using rule 130 (else -> .)
    }               reduce using rule 130 (else -> .)


    else                           shift and go to state 238

state 227

    (65) arglist -> arglist , arg .

    )               reduce using rule 65 (arglist -> arglist , arg .)
    ,               reduce using rule 65 (arglist -> arglist , arg .)



state 228

    (63) test_call -> test_call ( arglist , ) .

    ^               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    (               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    PLUSPLUS        reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    MINUSMINUS      reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    *               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    /               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    SLASHSLASH      reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    MOD             reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    +               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    -               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    LTLT            reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    GTGT            reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    <               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    LE              reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    >               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    GE              reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    NE              reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    EQ              reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    IS              reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    IN              reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    NOT             reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    |               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    AND             reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    OR              reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    ]               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    ,               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    )               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    }               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    NEWLINE         reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    $end            reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    {               reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    AS              reduce using rule 63 (test_call -> test_call ( arglist , ) .)
    :               reduce using rule 63 (test_call -> test_call ( arglist , ) .)



state 229

    (71) arg -> * * ident .

    )               reduce using rule 71 (arg -> * * ident .)
    ,               reduce using rule 71 (arg -> * * ident .)



state 230

    (69) arg -> ident = expression .

    )               reduce using rule 69 (arg -> ident = expression .)
    ,               reduce using rule 69 (arg -> ident = expression .)



state 231

    (20) hash_items -> hash_items , primitive : . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 239

state 232

    (21) hash_items -> hash_items , ident : . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 240

state 233

    (138) try_catch -> CATCH expression AS ident . block try_catch
    (131) block -> . { statements }

    {               shift and go to state 80


    block                          shift and go to state 241

state 234

    (137) try_catch -> CATCH expression block try_catch .

    ELSE            reduce using rule 137 (try_catch -> CATCH expression block try_catch .)
    NEWLINE         reduce using rule 137 (try_catch -> CATCH expression block try_catch .)
    $end            reduce using rule 137 (try_catch -> CATCH expression block try_catch .)
    }               reduce using rule 137 (try_catch -> CATCH expression block try_catch .)



state 235

    (77) index -> index , indice .

    ]               reduce using rule 77 (index -> index , indice .)
    ,               reduce using rule 77 (index -> index , indice .)



state 236

    (75) test_sub -> test_sub [ index , ] .

    [               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    .               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    ^               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    (               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    PLUSPLUS        reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    MINUSMINUS      reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    *               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    /               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    SLASHSLASH      reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    MOD             reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    +               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    -               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    LTLT            reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    GTGT            reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    <               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    LE              reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    >               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    GE              reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    NE              reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    EQ              reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    IS              reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    IN              reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    NOT             reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    |               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    AND             reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    OR              reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    NEWLINE         reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    $end            reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    )               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    ,               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    }               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    ]               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    {               reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    AS              reduce using rule 75 (test_sub -> test_sub [ index , ] .)
    :               reduce using rule 75 (test_sub -> test_sub [ index , ] .)



state 237

    (79) indice -> expression : expression . : expression
    (80) indice -> expression : expression .

    :               shift and go to state 242
    ]               reduce using rule 80 (indice -> expression : expression .)
    ,               reduce using rule 80 (indice -> expression : expression .)



state 238

    (134) for_s -> FOR many_idents IN comma_list block else .

    NEWLINE         reduce using rule 134 (for_s -> FOR many_idents IN comma_list block else .)
    $end            reduce using rule 134 (for_s -> FOR many_idents IN comma_list block else .)
    }               reduce using rule 134 (for_s -> FOR many_idents IN comma_list block else .)



state 239

    (20) hash_items -> hash_items , primitive : expression .

    ]               reduce using rule 20 (hash_items -> hash_items , primitive : expression .)
    ,               reduce using rule 20 (hash_items -> hash_items , primitive : expression .)
    }               reduce using rule 20 (hash_items -> hash_items , primitive : expression .)



state 240

    (21) hash_items -> hash_items , ident : expression .

    ]               reduce using rule 21 (hash_items -> hash_items , ident : expression .)
    ,               reduce using rule 21 (hash_items -> hash_items , ident : expression .)
    }               reduce using rule 21 (hash_items -> hash_items , ident : expression .)



state 241

    (138) try_catch -> CATCH expression AS ident block . try_catch
    (137) try_catch -> . CATCH expression block try_catch
    (138) try_catch -> . CATCH expression AS ident block try_catch
    (139) try_catch -> .

    CATCH           shift and go to state 92
    ELSE            reduce using rule 139 (try_catch -> .)
    NEWLINE         reduce using rule 139 (try_catch -> .)
    $end            reduce using rule 139 (try_catch -> .)
    }               reduce using rule 139 (try_catch -> .)


    try_catch                      shift and go to state 243

state 242

    (79) indice -> expression : expression : . expression
    (88) expression -> . test_or
    (24) test_or -> . test_or OR test_and
    (25) test_or -> . test_and
    (26) test_and -> . test_and AND test_not
    (27) test_and -> . test_not
    (28) test_not -> . NOT test_in
    (29) test_not -> . test_in
    (30) test_in -> . test_in IN test_type
    (31) test_in -> . test_in NOT IN test_type
    (32) test_in -> . test_in | test_type
    (33) test_in -> . test_type
    (34) test_type -> . test_type IS test_comp
    (35) test_type -> . test_type IS NOT test_comp
    (36) test_type -> . test_comp
    (37) test_comp -> . test_comp < test_io
    (38) test_comp -> . test_comp LE test_io
    (39) test_comp -> . test_comp > test_io
    (40) test_comp -> . test_comp GE test_io
    (41) test_comp -> . test_comp NE test_io
    (42) test_comp -> . test_comp EQ test_io
    (43) test_comp -> . test_io
    (44) test_io -> . test_io LTLT test_pm
    (45) test_io -> . test_io GTGT test_pm
    (46) test_io -> . test_pm
    (47) test_pm -> . test_pm + test_mdmf
    (48) test_pm -> . test_pm - test_mdmf
    (49) test_pm -> . test_mdmf
    (50) test_mdmf -> . test_mdmf * test_un
    (51) test_mdmf -> . test_mdmf / test_un
    (52) test_mdmf -> . test_mdmf SLASHSLASH test_un
    (53) test_mdmf -> . test_mdmf MOD test_un
    (54) test_mdmf -> . test_un
    (55) test_un -> . test_un PLUSPLUS
    (56) test_un -> . test_un MINUSMINUS
    (57) test_un -> . - test_un
    (58) test_un -> . + test_un
    (59) test_un -> . test_exp
    (60) test_exp -> . test_call ^ test_exp
    (61) test_exp -> . test_call
    (62) test_call -> . test_call ( arglist )
    (63) test_call -> . test_call ( arglist , )
    (64) test_call -> . test_attr
    (72) test_attr -> . test_attr . test_sub
    (73) test_attr -> . test_sub
    (74) test_sub -> . test_sub [ index ]
    (75) test_sub -> . test_sub [ index , ]
    (76) test_sub -> . test_basis
    (84) test_basis -> . primitive
    (85) test_basis -> . literal
    (86) test_basis -> . ident
    (87) test_basis -> . ( expression )
    (1) primitive -> . DEC
    (2) primitive -> . STRING
    (3) primitive -> . INT
    (4) primitive -> . NIL
    (5) primitive -> . BOOL
    (6) primitive -> . INF
    (8) literal -> . [ list_items ]
    (9) literal -> . [ list_items , ]
    (10) literal -> . [ ]
    (11) literal -> . [ hash_items ]
    (12) literal -> . [ hash_items , ]
    (13) literal -> . { list_items }
    (14) literal -> . { list_items , }
    (15) literal -> . { hash_items }
    (16) literal -> . { hash_items , }
    (17) literal -> . { }
    (7) ident -> . IDENT

    NOT             shift and go to state 23
    -               shift and go to state 50
    +               shift and go to state 11
    (               shift and go to state 3
    DEC             shift and go to state 20
    STRING          shift and go to state 53
    INT             shift and go to state 21
    NIL             shift and go to state 7
    BOOL            shift and go to state 45
    INF             shift and go to state 24
    [               shift and go to state 19
    {               shift and go to state 56
    IDENT           shift and go to state 15


    primitive                      shift and go to state 28
    test_exp                       shift and go to state 47
    test_and                       shift and go to state 30
    test_mdmf                      shift and go to state 31
    test_comp                      shift and go to state 34
    test_type                      shift and go to state 36
    literal                        shift and go to state 37
    test_un                        shift and go to state 5
    test_or                        shift and go to state 14
    test_basis                     shift and go to state 51
    test_sub                       shift and go to state 52
    test_call                      shift and go to state 17
    test_io                        shift and go to state 39
    test_in                        shift and go to state 40
    test_attr                      shift and go to state 58
    test_not                       shift and go to state 43
    ident                          shift and go to state 62
    test_pm                        shift and go to state 60
    expression                     shift and go to state 244

state 243

    (138) try_catch -> CATCH expression AS ident block try_catch .

    ELSE            reduce using rule 138 (try_catch -> CATCH expression AS ident block try_catch .)
    NEWLINE         reduce using rule 138 (try_catch -> CATCH expression AS ident block try_catch .)
    $end            reduce using rule 138 (try_catch -> CATCH expression AS ident block try_catch .)
    }               reduce using rule 138 (try_catch -> CATCH expression AS ident block try_catch .)



state 244

    (79) indice -> expression : expression : expression .

    ]               reduce using rule 79 (indice -> expression : expression : expression .)
    ,               reduce using rule 79 (indice -> expression : expression : expression .)


